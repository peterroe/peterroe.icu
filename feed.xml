<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Anthony Fu</title>
        <link>https://antfu.me/</link>
        <description>Anthony Fu' Blog</description>
        <lastBuildDate>Mon, 10 Jan 2022 05:11:25 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>Anthony Fu</title>
            <url>https://antfu.me/avatar.png</url>
            <link>https://antfu.me/</link>
        </image>
        <copyright>CC BY-NC-SA 4.0 2021 © Anthony Fu</copyright>
        <atom:link href="https://antfu.me/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Publish ESM and CJS in a single package]]></title>
            <link>https://antfu.me/posts/publish-esm-and-cjs</link>
            <guid>https://antfu.me/posts/publish-esm-and-cjs</guid>
            <pubDate>Mon, 29 Nov 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[A short tutorial of shipping both ESM and CJS dual formats in a single NPM package.]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<h2>ESM &amp; CJS</h2>
<ul>
<li>ESM - <a href="https://nodejs.org/api/esm.html">ECMAScript modules</a></li>
<li>CJS - <a href="https://nodejs.org/api/modules.html#modules-commonjs-modules">CommonJS</a></li>
</ul>
<p>In the past decade, due to the lack of a standard module system of JavaScript, CommonJS (a.k.a the <code>require('xxx')</code> and <code>module.exports</code> syntax) has been the way how Node.js and NPM packages work. Until 2015, when ECMAScript modules finally show up as the standard solution, the community start migrating to native ESM gradually.</p>
<pre><code class="language-js">// CJS
const circle = require('./circle.js')
console.log(`The area of a circle of radius 4 is ${circle.area(4)}`)
</code></pre>
<pre><code class="language-js">// ESM
import { area } from './circle.mjs'
console.log(`The area of a circle of radius 4 is ${area(4)}`)
</code></pre>
<p>ESM enables named exports, better static analysis, tree-shaking, browsers native support, and most importantly, as a standard, it's basically the future of JavaScript.</p>
<p>Experimental support of native ESM is introduced in Node.js v12, and stabilized in v12.22.0 and v14.17.0. As the end of 2021, many packages now ship in pure-ESM format, or CJS and ESM dual formats; meta-frameworks like <a href="https://github.com/nuxt/framework">Nuxt 3</a> and <a href="https://github.com/sveltejs/kit">SvelteKit</a> are now recommending users to use ESM-first environment.</p>
<p>The overall migration of the ecosystem is still in progress, for most library authors, shipping dual formats is a safer and smoother way to have the goods from both worlds. In the rest of this blog post, I will show you why and how.</p>
<h2>Compatibility</h2>
<p>If ESM is the better and the future, why don't we all move to ESM then? Even though Node.js is smart enough to allow CJS and ESM packages to work together, the main blocker is that <strong>you can't use ESM packages in CJS</strong>.</p>
<p>If you do:</p>
<pre><code class="language-ts">// in CJS
const pkg = require('esm-only-package')
</code></pre>
<p>you will receive the following error</p>
<pre><code class="language-bash">Error [ERR_REQUIRE_ESM]: require() of ES Module esm-only-package not supported.
</code></pre>
<p>The root cause is that ESM is asynchronous by nature, meaning you can't import an async module in synchronous context that <code>require</code> is for. This commonly means <strong>if you want to use ESM packages, you have to use ESM as well</strong>. Only one exception is that you can use ESM package in CJS using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports">dynamic <code>import()</code></a>:</p>
<pre><code class="language-ts">// in CJS
const { default: pkg } = await import('esm-only-package')
</code></pre>
<p>Since dynamic import will return a Promise, meaning all the sub-sequential callee need to be async as well (so call <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">Red Functions</a>, or I prefer call it Async Infection). In some case it might work, but generally I won't think this to be an easy approachable solution for users.</p>
<p>On the other hand, if you are able to go with ESM directly, it would be much easier as <code>import</code> supports both ESM and CJS.</p>
<pre><code class="language-ts">// in ESM
import { named } from 'esm-package'
import cjs from 'cjs-package' 
</code></pre>
<p>Some packages now ship <a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">pure-ESM packages</a> advocating the ecosystem to move from CJS to ESM. While this might be the &quot;right thing to do&quot;, however, giving the fact that that majority of the ecosystem are still on CJS and the migration is not that easy, I found myself more lean to ship both CJS and ESM formats to make the transition smoother.</p>
<h3><code>package.json</code></h3>
<p>Luckily, Node allows you to have those two formats in a single package at the same time. With the new <a href="https://nodejs.org/api/packages.html#conditional-exports"><code>exports</code></a> field in <code>package.json</code>, you can now specify multiple entries to provide those formats conditionally. Node will resolve to the version based on user's or downstream packages environment.</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;my-cool-package&quot;,
  &quot;exports&quot;: {
    &quot;.&quot;: {
      &quot;require&quot;: &quot;./index.cjs&quot;, // CJS
      &quot;import&quot;: &quot;./index.mjs&quot;   // ESM
    }
  }
}
</code></pre>
<h2>Bundling</h2>
<p>So now we have two copies of code with slightly different module syntax to maintain, duplicating them is of course not an ideal solution. At this point you might need to consider introducing some build tools or bundling process to build your code into multiple formats. This might remind you the nightmare of configuring complex Webpack or Rollup, well don't worry, my mission today is to introduce you two awesome tools that make your life so much easier.</p>
<ul>
<li><a href="#tsup"><code>tsup</code></a></li>
<li><a href="#unbuild"><code>unbuild</code></a></li>
</ul>
<h3>tsup</h3>
<p><a href="https://github.com/egoist/tsup"><code>tsup</code></a> by <a href="https://github.com/egoist">@egoist</a> is one of my most used tools. The features zero-config building for TypeScript project. The usage is like:</p>
<pre><code class="language-bash">$ tsup src/index.ts
</code></pre>
<p>And then you will have <code>dist/index.js</code> file ready for you to publish.</p>
<p>To support dual formats, it's just a flag away:</p>
<pre><code class="language-bash">$ tsup src/index.ts --format cjs,esm
</code></pre>
<p>Two files <code>dist/index.js</code> and <code>dist/index.mjs</code> will be generated with it and you are good to go. Powered by <a href="https://github.com/evanw/esbuild"><code>esbuild</code></a>, <code>tsup</code> is not only super easy to use but also incredible fast. I highly recommend to give it a try.</p>
<p>Here is my go-to template of <code>package.json</code> using <code>tsup</code>:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;my-cool-package&quot;,
  &quot;main&quot;: &quot;./dist/index.js&quot;,
  &quot;module&quot;: &quot;./dist/index.mjs&quot;,
  &quot;types&quot;: &quot;./dist/index.d.ts&quot;,
  &quot;exports&quot;: {
    &quot;.&quot;: {
      &quot;require&quot;: &quot;./dist/index.js&quot;,
      &quot;import&quot;: &quot;./dist/index.mjs&quot;,
      &quot;types&quot;: &quot;./dist/index.d.ts&quot;      
    }
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsup src/index.ts --format cjs,esm --dts --clean&quot;,
    &quot;watch&quot;: &quot;npm run build -- --watch src&quot;,
    &quot;prepublishOnly&quot;: &quot;npm run build&quot;
  }
}
</code></pre>
<h3>unbuild</h3>
<p>If we say <code>tsup</code> is a minimal bundler for TypeScript, <a href="https://github.com/unjs/unbuild"><code>unbuild</code></a> by the <a href="https://github.com/unjs">@unjs org</a> is a more generalized, customizable and yet powerful. <code>unbuild</code> is being used to bundle Nuxt 3 and it's sub packages.</p>
<p>To use it, we create <code>build.config.ts</code> file in the root</p>
<pre><code class="language-ts">// build.config.ts
import { defineBuildConfig } from 'unbuild'

export default defineBuildConfig({
  entries: [
    './src/index'
  ],
  declaration: true, // generate .d.ts files
})
</code></pre>
<p>and run the <code>unbuild</code> command:</p>
<pre><code class="language-bash">$ unbuild
</code></pre>
<p><code>unbuild</code> will generate both ESM and CJS for you by default!</p>
<h4>Stubbing</h4>
<p>This is one of the most incredible things that I have found when I first looked into <a href="https://github.com/nuxt/framework">Nuxt 3's codebase</a>. <code>unbuild</code> introduced a new idea called Stubbing. Instead of firing up a watcher to re-trigger the bundling every time you made changes to the source code, the stubbing in <code>unbuild</code> (so call Passive watcher) does not require you are have another process for that at all. By calling the following command <strong>only once</strong>:</p>
<pre><code class="language-bash">$ unbuild --stub
</code></pre>
<p>You are able to play and test out with your library with the up-to-date code!</p>
<p>Want to know the magic? After running the stubbing command, you can check out the generated distribution files:</p>
<pre><code class="language-ts">// dist/index.mjs
import jiti from 'jiti'
export default jiti(null, { interopDefault: true })('/Users/antfu/unbuild-test/src/index')
</code></pre>
<pre><code class="language-ts">// dist/index.cjs
module.exports = require('jiti')(null, { interopDefault: true })('/Users/antfu/unbuild-test/src/index')
</code></pre>
<p>Instead of the distribution of your code bundle, the dist files are now redirecting to your source code with a wrap of <a href="https://github.com/unjs/jiti"><code>jiti</code></a> - another treasure hidden in the <a href="https://github.com/unjs">@unjs</a> org. <code>jiti</code> provides the runtime support of TypeScript, ESM for Node by transpiling the modules on the fly. Since it directly goes to your source files, there won't be a misalignment between your source code and bundle dist - thus there is no watcher process needed! This is a huge DX bump for library authors, if you still not getting it, you shall definitely grab it down and play with it yourself.</p>
<h4>Bundleless Build</h4>
<p>Powered by <a href="https://github.com/unjs/mkdist"><code>mkdist</code></a> - another <a href="https://github.com/unjs">@unjs</a> package - <code>unbuild</code> also handles static assets and file-to-file transpiling. Bundleless build allows you to keep the structure of your source code, made easy for importing submodules on-demand to optimizing performance and more.</p>
<p>Config in <code>unbuild</code> will look like:</p>
<pre><code class="language-ts">// build.config.ts
import { defineBuildConfig } from 'unbuild'

export default defineBuildConfig({
  entries: [
    // bundling
    'src/index',
    // bundleless, or just copy assets
    { input: 'src/components/', outDir: 'dist/components' },
  ],
  declaration: true,
})
</code></pre>
<p>One of the coolest features on this is that it handles <code>.vue</code> file out-of-box. For example, if I have a component <code>MyComponent.vue</code> under <code>src/components</code> with following content:</p>
<pre><code class="language-html">&lt;!-- src/components/MyComponent.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ count }}&lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
const count: number | string = 0

export default {
  data: () =&gt; ({ count }),
}
&lt;/script&gt;
</code></pre>
<p>Notice that we are using TypeScript in the Vue file, when we do the build, the component will be copied over but with the TypeScript annotation removed along with a <code>MyComponent.vue.d.ts</code> generated.</p>
<pre><code class="language-html">&lt;!-- dist/components/MyComponent.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ count }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
const count = 0
export default {
  data: () =&gt; ({ count })
}
&lt;/script&gt;
</code></pre>
<pre><code class="language-ts">// dist/components/MyComponent.vue.d.ts
declare const _default: {
  data: () =&gt; {
    count: number | string
  }
}
export default _default
</code></pre>
<p>This way this allows you to use TypeScript in development while not requiring consumers to also have TypeScript in their setup.</p>
<p>P.S. <code>unbuild</code> is working on providing better out-of-box experience by auto infering the entries in <code>package.json</code>, <a href="https://github.com/unjs/unbuild/issues/3">learn more</a>.</p>
<h2>Context Misalignment</h2>
<p>With either of the tools mentioned above, now we are able to write TypeScript as the single source of truth and made the overall codebase easier to maintain. However, there are still some caveats that you will need to keep an eye on it.</p>
<p><strong>In ESM, there is NO <code>__dirname</code>, <code>__filename</code>, <code>require</code>, <code>require.resolve</code></strong>. Instead, you will need to use <code>import.meta.url</code> and also do some convertion to get the file path string.</p>
<p>So since our code will be compiled to both CJS and ESM, it's better to avoiding using those environment specific context whenever possible. If you do need them, you can refer to my note about <a href="/notes#isomorphic-dirname">Isomorphic <code>__dirname</code></a>:</p>
<pre><code class="language-ts">import { dirname } from 'path'
import { fileURLToPath } from 'url'

const _dirname = typeof __dirname !== 'undefined'
  ? __dirname
  : dirname(fileURLToPath(import.meta.url))
</code></pre>
<p>For <code>require</code> and <code>require.resolve</code>, you can use</p>
<pre><code class="language-ts">import { createRequire } from 'module'

const require = createRequire(import.meta.url)
</code></pre>
<p>Some good news, if you are using <code>unbuild</code>, you can turn on the <code>cjsBridge</code> flag and <code>unbuild</code> will shims those CJS context in ESM automatically for you!.</p>
<pre><code class="language-ts">import { defineBuildConfig } from 'unbuild'

export default defineBuildConfig({
  cjsBridge: true, // &lt;--
})
</code></pre>
<p>On the other hand, if you are using <code>tsup</code>, it will shims ESM's <code>import.meta.url</code> for you in CJS instead.</p>
<h2>Final words</h2>
<p>This blog post showcased you only a few features of both tools. Do check their docs for more details. And hope you find these setups useful for building your own libraries. If you have any comments or suggestions, ping me on Twitter <a href="https://twitter.com/antfu7">@antfu7</a>. Happy hacking!</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Icons in Pure CSS]]></title>
            <link>https://antfu.me/posts/icons-in-pure-css</link>
            <guid>https://antfu.me/posts/icons-in-pure-css</guid>
            <pubDate>Sun, 31 Oct 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[The icon solution in pure CSS.]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<blockquote>
<p><a href="/posts/icons-in-pure-css-zh">中文 Chinese Version</a></p>
</blockquote>
<p>In my previous post about <a href="/posts/reimagine-atomic-css#pure-css-icons">Reimagine Atomic CSS</a>, I introduced a preset of <a href="https://github.com/antfu/unocss">UnoCSS</a> that provides the ability to <strong>use any icons on-demand in purely CSS</strong>. Today in this post, I'd like to share with you how we made it possible.</p>
<h2>My Icon Explorations</h2>
<p>If you are interested in how I get here, there is an index of my previous post about the stories of my icon explorations and experiments.</p>
<ul>
<li>Aug. 2020 - <a href="/posts/journey-with-icons">Journey with Icons</a></li>
<li>Sep. 2021 - <a href="/posts/journey-with-icons-continues">Journey with Icons Continues</a></li>
<li>Oct. 2021 - <a href="/posts/reimagine-atomic-css#pure-css-icons">Reimagine Atomic CSS (The CSS Icons Preset)</a></li>
<li>Nov. 2021 - Icons in Pure CSS - <em>you are here!</em></li>
</ul>
<h2>Prior Arts</h2>
<p>I know there is a Pure CSS icon solution called <a href="https://github.com/astrit/css.gg"><code>css.gg</code></a>, which is a great idea to use pseudo-elements (<code>::before</code>, <code>::after</code>) to construct the icons. However, that could require some expert knowledge of how CSS works, but I imagine that approach could be hard to create more complex icons. Instead of the limited choices in a specific set, I am seeking <strong>a more general solution that could apply to any icons</strong>.</p>
<h2>The Idea</h2>
<p>The idea come from <a href="https://github.com/antfu/unplugin-icons/issues/88">this feature request</a> created by <a href="https://github.com/husayt">@husayt</a> to <code>unplugin-icons</code> and the initial implementation in <a href="https://github.com/antfu/unplugin-icons/pull/90">this pull request</a> by <a href="https://github.com/userquin">@userquin</a>. The idea here is quite straightforward - to generate CSS with the icons in <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">DataURI</a> as the background image.</p>
<pre><code class="language-css">.my-icon {
  background: url(data:...) no-repeat center;
  background-color: transparent;
  background-size: 16px 16px;
  height: 16px;
  width: 16px;
  display: inline-block;
}
</code></pre>
<p>With that, we could use any images inlined in CSS with a single class.</p>
<div grid="~ cols-2">
<pre><code class="language-html">&lt;div class=&quot;my-icon&quot;&gt;&lt;/div&gt; 
</code></pre>
<div i-twemoji-grinning-face text-5xl my-auto mx-4 />
</div>
<p>It's indeed an interesting idea. However, this is more like an image instead of an icon. To me, an icon has to be scalable and colorable (if it's monochrome).</p>
<h2>Make it Work</h2>
<h3>DataURI</h3>
<p>Thanks again to <a href="https://iconify.design/">Iconify</a>, which unified 100+ icon sets with 10,000+ icons into <a href="https://github.com/iconify/collections-json">the consistent JSON format</a>. It allows us to get the SVG of any icon set by simply providing the collection and icon ids. The usage is like this:</p>
<pre><code class="language-ts">import { iconToSVG, getIconData } from '@iconify/utils'

const svg = iconToSVG(getIconData('mdi', 'alarm'))
// (this is not the exact API, simplified here for demo)
</code></pre>
<p>Once we got the SVG string, we could convert the it to DataURI:</p>
<pre><code class="language-ts">const dataUri = `data:image/svg+xml;base64,${Buffer.from(svg).toString('base64')}`
</code></pre>
<p>Talking about DataURI, it's almost the default choice to use <a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64">Base64</a> until I read <a href="https://css-tricks.com/probably-dont-base64-svg/">Probably Don't Base64 SVG</a> by Chris Coyier. Base64 is needed to encode binary data like images to be used in plain text files like CSS, while for SVG, since it's already in text format, the extra encoding to Base64 actually makes the file size larger.</p>
<p>Combine the technique mentioned in <a href="https://codepen.io/Tigt/post/optimizing-svgs-in-data-uris">Optimizing SVGs in data URIs</a> by Taylor Hunt to improve the output size, further, here is the solution we end up with.</p>
<pre><code class="language-ts">// https://bl.ocks.org/jennyknuth/222825e315d45a738ed9d6e04c7a88d0
function encodeSvg(svg: string) {
  return svg.replace('&lt;svg', (~svg.indexOf('xmlns') ? '&lt;svg' : '&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;'))
    .replace(/&quot;/g, '\'')
    .replace(/%/g, '%25')
    .replace(/#/g, '%23')
    .replace(/{/g, '%7B')
    .replace(/}/g, '%7D')
    .replace(/&lt;/g, '%3C')
    .replace(/&gt;/g, '%3E')
}

const dataUri = `data:image/svg+xml;utf8,${encodeSvg(svg)}`
</code></pre>
<h3>Scalable</h3>
<p>The first step of making the &quot;image&quot; more like an icon, we need to make it scalable to the context.</p>
<p>Luckily we have the first-class support scaling support - the <code>em</code> unit.</p>
<pre><code class="language-css">.my-icon {
  background: url(data:...) no-repeat center;
  background-color: transparent;
  background-size: 100% 100%;
  height: 1em;
  width: 1em;
}
</code></pre>
<p>By changing the <code>height</code> and <code>width</code> to <code>1em</code>, and the <code>background-size</code> to <code>100%</code>, we made the image scales based on the parent's font size.</p>
<ul>
<li><span text-sm>Small <span inline-block vertical-text-bottom i-ri-bike-line></span></span></li>
<li><span text-base>Normal <span inline-block vertical-text-bottom i-ri-bike-line></span></span></li>
<li><span text-xl>Large <span inline-block vertical-text-bottom i-ri-bike-line></span></span></li>
</ul>
<h3>Colorable</h3>
<p>In inlined SVG, we could use <a href="https://www.w3.org/TR/css-color-3/#currentcolor"><code>fill=&quot;currentColor&quot;</code></a> to make the color of the SVG matches with the current text color. However, when we use it as a background image, it becomes a flat image. The dynamic parts of the SVG are lost, so is the <code>currentColor</code> magic (it's just like you can't override the color of a PNG).</p>
<p>If you do a quick search, you will find that most people are telling you that you can't. Some might offer you the option to assign the colors in the SVG before converting to DataURI, which could solve the specific problem that you want the icon to have color, but not the root cause that the color is not reactive to the context.</p>
<p>Then you might come up with the idea of using <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter">CSS filters</a>, like Una Kravets mentioned in <a href="https://css-tricks.com/solved-with-css-colorizing-svg-backgrounds/">Solved with CSS! Colorizing SVG Backgrounds</a>. That sounds valid, but only that you need to calculate the matrix of how to transform the color to the desired ones. Probably feasible by introducing some runtime JavaScript for that? Maybe, if so, we lost the whole point of trying icons in pure CSS.</p>
<p>This sounds like a dead-end to me. Until I accidentally found the article <a href="https://codepen.io/noahblon/post/coloring-svgs-in-css-background-images">Coloring SVGs in CSS Background Images</a> by Noah Blon. In the article, Noah mentioned a brilliant idea of using <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mask">CSS masks</a> - a property that I have never heard of before.</p>
<pre><code class="language-css">.my-icon {
  background-color: red;
  mask-image: url(icon.svg);
}
</code></pre>
<p>Instead of using the icon as a background image and figuring out a way to color it, we could actually use the icon as a mask to clip the filled background color. Furthermore, we could now use the <code>currentColor</code> magic to have the icon matching with the parent text color!</p>
<pre><code class="language-css">.my-icon {
  background-color: currentColor;
  mask-image: url(icon.svg);
}
</code></pre>
<div pt-4 />
<div text-sky text-xl>This is a blue text, with the blue icon <div i-uil-cloud-showers-heavy /><div i-uil:wind /></div>
<div text-lime text-xl>Green <div i-uil:trees /><div i-uil:desert /></div>
<div text-orange text-xl>Orange <div i-uil:restaurant /><div i-uil:store-alt /></div>
<h3>Icons with Colors</h3>
<p>We made the monochrome icons colorable but now it problem comes to the icons with colors. With the mask approach, the colors and content of the icons got lost, for example:</p>
<div text-4xl inline-flex gap-2 py-4 px-8 bg-gray-400:15 rounded>
<div text-base my-auto>Icon:</div>
<div i-twemoji:astonished-face />
<div text-base my-auto ml-4>Masked:</div>
<div i-ph:circle-fill style="transform: scale(1.3)" />
</div>
<p>Yes, I might say it's hard for one approach to cover all the cases.</p>
<p>Unless - you could <strong>blend two approaches into one</strong>! Remember we just talked about the background image approach serving the icons as images? Isn't that just what we want for colored icons? - We don't need to change the colors after all!</p>
<p>So the solution is actually pretty simple, we just need to find a way to distinguish the monochrome and colored icons smartly. Luckily, since we had access the the SVG content, we could have:</p>
<pre><code class="language-ts">// if an SVG icon have the `currentColor` value,
// it's very likely to be a monochrome icon
const mode = svg.includes('currentColor')
  ? 'mask'
  : 'background-img'

const uri = `url(&quot;data:image/svg+xml;utf8,${encodeSvg(svg)}&quot;)`

// monochrome
if (mode === 'mask') {
  return {
    'mask': `${uri} no-repeat`,
    'mask-size': '100% 100%',
    'background-color': 'currentColor',
    'height': '1em',
    'width': '1em',
  }
}
// colored
else {
  return {
    'background': `${uri} no-repeat`,
    'background-size': '100% 100%',
    'background-color': 'transparent',
    'height': '1em',
    'width': '1em',
  }
}
</code></pre>
<p>And it works surprisingly well! You know, it's now behavior similar to the thing we are using daily - system's native emojis. The color of texts changes based on the context, while emojis stay the colors of their own.</p>
<p>Here are some showcases of what we end up with:</p>
<div text-xl all:mx-1 all:my-2 all:vertical-middle>
<p><span op60 text-sm inline-block w-40 text-right>Material Design</span> <div i-ic:baseline-account-circle /> <div i-ic:baseline-card-membership /> <div i-ic:baseline-verified text-green5 /> <div i-ic:outline-explore text-sky5 /><br>
<br><span op60 text-sm inline-block w-40 text-right>Carbon</span> <div i-carbon:chart-multitype /> <div i-carbon:network-4 /> <div i-carbon:wind-gusts /> <div i-carbon:collaborate /><br>
<br><span op60 text-sm inline-block w-40 text-right>Tabler</span> <div i-tabler:building-carousel /> <div i-tabler:circle-square /> <div i-tabler:color-swatch /> <div i-tabler:cut /><br>
<br><span op60 text-sm inline-block w-40 text-right>Twemoji</span> <div i-twemoji:grinning-face-with-smiling-eyes /> <div i-twemoji:face-in-clouds /> <div i-twemoji:weary-cat /> <div i-twemoji:teacup-without-handle /><br>
<br><span op60 text-sm inline-block w-40 text-right>Logos</span> <div i-logos:vue /> <div i-logos:blender /> <div i-logos:chrome /> <div i-logos:codepen-icon /></p>
</div>
<p>To see and find all the icons available, you can check out my other project <a href="https://icones.js.org/">Icônes</a>.</p>
<h2>Use It</h2>
<p>If you want to try this icons solution in your project, you can install <a href="https://github.com/antfu/unocss">UnoCSS</a> and the icons preset:</p>
<pre><code class="language-bash">npm i -D unocss @unocss/preset-icons @iconify/json
</code></pre>
<p><code>@iconify/json</code> is the package that stores the icon data from Iconify. Alternatively, you could install per icon set, for example, <code>@iconify-json/mdi</code> for Material Design Icons or <code>@iconify-json/carbon</code> for Carbon Icons and so on.</p>
<p>Then in your <code>vite.config.js</code></p>
<pre><code class="language-ts">import { defineConfig } from 'vite'
import Unocss from 'unocss'
import UnocssIcons from '@unocss/preset-icons'

export default defineConfig({
  plugins: [
    Unocss({
      // when `presets` is specified, the default preset will be disabled
      // so you could only use the pure CSS icons in addition to your
      // existing app without polluting other CSS 
      presets: [
        UnocssIcons({
          // options
          prefix: 'i-',
          extraProperties: {
            display: 'inline-block'
          }
        }),
        // presetUno() - if you want to use other atomic CSS as well
      ],
    }),
  ],
})
</code></pre>
<p>And that's it for today. Hope you enjoy this icons solution from UnoCSS, or get some inspiration from it for your own projects.</p>
<p>Thanks for reading, and see you :)</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Reimagine Atomic CSS]]></title>
            <link>https://antfu.me/posts/reimagine-atomic-css</link>
            <guid>https://antfu.me/posts/reimagine-atomic-css</guid>
            <pubDate>Tue, 26 Oct 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[Let's take a step back and reimagine what's atomic CSS could be in the best.]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<blockquote>
<p>This post will be a bit longer than usual. It's quite a big announcement to me, and there are many things I want to talk about. I'll be appreciated if you take the time to read through it. The table of contents is hidden on the right if you are on a desktop. Hope you enjoy :)</p>
</blockquote>
<blockquote>
<p><a href="/posts/reimagine-atomic-css-zh">中文 Chinese Version</a></p>
</blockquote>
<h2>What is Atomic CSS?</h2>
<p>Let's first give a proper definition to <strong>Atomic CSS</strong>:</p>
<p>From <a href="https://css-tricks.com/lets-define-exactly-atomic-css/">this article</a> by John Polacek:</p>
<blockquote>
<p>Atomic CSS is the approach to CSS architecture that favors small, single-purpose classes with names based on visual function.</p>
</blockquote>
<p>Some might also call it Functional CSS, or CSS utilities. Basically, you can say an Atomic CSS framework is a collection of the CSS like these:</p>
<pre><code class="language-css">.m-0 {
  margin: 0;
}
.text-red {
  color: red;
}
/* ... */
</code></pre>
<p>We have quite a few utilities-first CSS framework like <a href="https://tailwindcss.com/">Tailwind CSS</a>, <a href="https://windicss.org/">Windi CSS</a> and <a href="https://tachyons.io/">Tachyons</a>, etc. And there are also some UI libraries that come with some CSS utilities as the complement to the framework, for example <a href="https://getbootstrap.com/docs/5.1/utilities/api/">Bootstrap</a> and <a href="https://chakra-ui.com/docs/features/style-props">Chakra UI</a>.</p>
<p>We are not going to talk about the pros and cons of using atomic CSS here, as you might hear them many times already. Today, we are going to use a framework author's perspective to see how we make the trade-off building those frameworks you love, their limitations, what we can do better to eventually benefits your daily work.</p>
<h2>The Background</h2>
<p>Before we start, let's talk a bit about the background. If you don't know me, my name is Anthony Fu, and I am a <a href="https://vitejs.dev/">Vite</a> team member and the creator of <a href="https://github.com/antfu/vitesse">Vitesse</a>, one of the most popular starter templates for Vite. I enjoy the speedy development experience of atomic CSS (or CSS utilities), so I chose to use <a href="https://tailwindcss.com/">Tailwind CSS</a> as the default UI framework for Vitesse. While Vite should be incredibly fast compared to Webpack and others, Tailwind, which generates megabytes of utility CSS, makes the start-up and HMR on Vite slow as the old days. I once thought this was some kind of trade-off for using atomic CSS solutions - until I discovered <a href="https://windicss.org">Windi CSS</a>.</p>
<img src="https://antfu.me/images/discover-windicss.png" class="transform scale-110 py-2"/>
<p><a href="https://windicss.org">Windi CSS</a> was a Tailwind CSS alternative that was written from scratch. It has zero dependencies and does not rely on PostCSS and Autoprefixer. More importantly, it features <strong>on-demanded usage</strong>. Instead of generating all the combinations of utilities that you rarely used to purge later, Windi CSS only generates those actually presented in your codebase. This fits perfectly well with Vite's on-demanded philosophy, and theoretically, it should be way much faster than Tailwind. So I wrote <a href="https://github.com/windicss/vite-plugin-windicss">the Vite plugin</a> for it, and it turned out to be <a href="https://twitter.com/antfu7/status/1361398324587163648">20~100x faster</a> than Tailwind.</p>
<p>It went pretty well, Windi CSS grown into a team, we made many more innovations like <a href="https://windicss.org/features/value-auto-infer.html">Value Infering</a>, <a href="https://windicss.org/features/variant-groups.html">Variant Groups</a>, <a href="https://windicss.org/features/shortcuts.html">Shortcuts</a>, <a href="https://twitter.com/antfu7/status/1372244287975387145">Design in DevTools</a>, <a href="https://twitter.com/windi_css/status/1387460661135896577">Attributify Mode</a>, etc. As the result, Tailwind was <a href="https://twitter.com/adamwathan/status/1371542711086559237?s=20">ass kicked</a> to introduce their own on-demand <a href="https://tailwindcss.com/docs/just-in-time-mode">JIT engine</a>.</p>
<h2>Breakdown Atomic CSS</h2>
<p>Back to the topic, let's take a look at how atomic CSS works first.</p>
<h3>Traditional Way</h3>
<p>The traditional way of making Atomic CSS is to provide all the CSS utilities you might possibly want, for example, here is something you could generate your own with a preprocessor (SCSS in this case):</p>
<pre><code class="language-scss">// style.scss

@for $i from 1 through 10 {
  .m-#{$i} {
    margin: $i / 4 rem;
  }
}
</code></pre>
<p>It will be compiled to:</p>
<pre><code class="language-css">.m-1 { margin: 0.25 rem; }
.m-2 { margin: 0.5 rem; }
/* ... */
.m-10 { margin: 2.5 rem; }
</code></pre>
<p>Great, now you can use <code>class=&quot;m-1&quot;</code> to set the margin. But as you might see, with this approach, you can't set the margin outside of 1 to 10, and also, you need to pay the cost of shipping 10 CSS rules even if you have only used one. Later if you want to support different margin directions like <code>mt</code> for <code>margin-top</code>, <code>mb</code> for <code>margin-bottom</code>. With those 4 directions, you are multiplying your CSS size by 5. Then when it comes to variants like <code>hover:</code> and <code>focus:</code> - you know the story. At that point, adding one more utility often means you are going to introduce a few extra kilobytes. Thus, this is also why the traditional Tailwind ships megabytes of CSS.</p>
<p>To solve this, Tailwind came up with the solution by using <a href="https://purgecss.com/">PurgeCSS</a> to scan your dist bundle and remove the rules you don't need. Now you have only a few KBs of CSS in production. However, note that the purging would only work in the production build, meaning you are still working with the tremendous CSS in development. It wasn't that prominent in Webpack, but it becomes a pain in Vite, given the rest are now coming blazing fast.</p>
<p>While generating and purging approach have its limitations, could we have a better solution?</p>
<h3>On-demand Way</h3>
<p>The &quot;on-demand&quot; idea introduces a brand new way of thinking. Let's make a comparison of the approaches here.</p>
<img src="/images/unocss-traditional-way.png" class="filter dark:invert" />
<p>The traditional way not only costs you unnecessary computation (generated but not in use) but is also unable to satisfy your needs that are not included in the first place.</p>
<img src="/images/unocss-on-demand-way.png" class="filter dark:invert" />
<p>By flipping the order of &quot;generating&quot; and &quot;usage scanning&quot;, the &quot;on-demand&quot; approach saves you the wasted computational and transferring cost, while being flexible to provide the dynamic needs that pre-generating can't possibly be covered. Meanwhile, this approach could be used in both development and production, provide more confidence about the consistency and make HMR more efficient.</p>
<p>To achieve this, both Windi CSS and Tailwind JIT take the approach of pre-scanning your source code. Here is a simple example of that:</p>
<pre><code class="language-ts">import glob from 'fast-glob'
import { promises as fs } from 'fs'

// this usually comes from user config
const include = ['src/**/*.{jsx,tsx,vue,html}']

async function scan() {
  const files = await glob(include)

  for (const file of files) {
    const content = await fs.readFile(file, 'utf8')
    // pass the content to the generator and match for class usages
  }
}

await scan()
// scanning is done before the build / dev process
await buildOrStartDevServer()
</code></pre>
<p>To provide HMR during development, a <a href="https://github.com/paulmillr/chokidar">file watcher</a> is usually needed:</p>
<pre><code class="language-ts">import chokidar from 'chokidar'

chokidar.watch(include).on('change', (event, path) =&gt; {
  // read the file again
  const content = await fs.readFile(file, 'utf8')
  // pass the content to the generator again
  // invalidate the css module and send HMR event
})
</code></pre>
<p>As a result, with the on-demand approach, Windi CSS is able to provide about <a href="https://twitter.com/antfu7/status/1361398324587163648">100x faster performance</a> than the traditional Tailwind CSS.</p>
<h2>The Itches</h2>
<p>I am now using Windi CSS on almost all my apps, and it works pretty well. The performance is sweet, and the HMR is unnoticeable. <a href="https://windicss.org/features/value-auto-infer.html">Value Auto Infering</a> and <a href="https://twitter.com/windi_css/status/1387460661135896577">Attributify Mode</a> makes my development even faster. I could really take a good sleep and dream about other things then. However, it sometimes itches me from my sweet dream.</p>
<p>The one I found annoying is the unclearness of what I am getting and what to do to make it work. To me, the best ideally atomic CSS should be invisible. Once learned, it should be intuitive and analogous to know the others. It's invisible when it works as you expect and could become frustrating when it doesn't.</p>
<p>For example, you know that in Tailwind's <code>border-2</code> means <code>2px</code> of border width, <code>4</code> for <code>4px</code>, <code>6</code> for <code>6px</code>, <code>8</code> for <code>8px</code>, but guess what, <code>border-10</code> <strong>does NOT work</strong> (it could also take your time to figure it out!). You might say this is designed on purpose by Tailwind to make the design system consistent and limited. Ok fine, but here is a quick quiz, <strong>let's say if you want <code>border-10</code> to work, how would you do that?</strong></p>
<p>Write your own utility somewhere in your global styles?</p>
<pre><code class="language-css">.border-10 {
  border-width: 10px;
}
</code></pre>
<p>That's pretty fast and straightforward. And importantly, it works. But honestly, if I need to do this manually myself, why would I need Tailwind in the first place?</p>
<p>If you know Tailwind a bit more, you might know it can be configured. So you spend 5 minutes searching for their docs, here is what you <a href="https://tailwindcss.com/docs/border-width#border-widths">end up with</a>:</p>
<pre><code class="language-js">// tailwind.config.js
module.exports = {
  theme: {
    borderWidth: {
      DEFAULT: '1px',
      '0': '0',
      '2': '2px',
      '3': '3px',
      '4': '4px',
      '6': '6px',
      '8': '8px',
      '10': '10px' // &lt;-- here
    }
  }
}
</code></pre>
<p>Ah, fair enough, now we could list them all and get back to work... wait, where was I? The original task you are working on gets lost, and it takes time to get back to the context again. Later on, if we want to set border colors, we'd need to look up the docs again to see how it could be configured and so on. Maybe someone would enjoy this workflow, but it's not for me. I don't enjoy being interpreted by something that should intuitively work.</p>
<p>Windi CSS is more relaxed to the rules and will try to provide the corresponding utilities whenever possible. In the previous case, <code>border-10</code> will work out-of-box on Windi (thank you!). But due to the fact that Windi is compatible with Tailwind, it has also to use the exact same configuration interface as Tailwind. While the number inferring works in Windi, it would still be a nightmare if you want to add custom utilities. Here is an example from <a href="https://tailwindcss.com/docs/plugins#escaping-class-names">Tailwind's docs</a>:</p>
<pre><code class="language-ts">// tailwind.config.js
const _ = require('lodash')
const plugin = require('tailwindcss/plugin')

module.exports = {
  theme: {
    rotate: {
      '1/4': '90deg',
      '1/2': '180deg',
      '3/4': '270deg',
    }
  },
  plugins: [
    plugin(function({ addUtilities, theme, e }) {
      const rotateUtilities = _.map(theme('rotate'), (value, key) =&gt; {
        return {
          [`.${e(`rotate-${key}`)}`]: {
            transform: `rotate(${value})`
          }
        }
      })

      addUtilities(rotateUtilities)
    })
  ]
}
</code></pre>
<p>That along is to generate these:</p>
<pre><code class="language-css">.rotate-1\/4 {
  transform: rotate(90deg);
}
.rotate-1\/2 {
  transform: rotate(180deg);
}
.rotate-3\/4 {
  transform: rotate(270deg);
}
</code></pre>
<p>The code to generate the CSS is even longer than the outcome. It could be hard to read and maintain, and meanwhile, it breaks the on-demand ability.</p>
<p>Tailwind's API and plugin system is designed with the traditional mindset and does not really match the new on-demand approach. Core utilities are baked in the generator, and the customization is quite limited. So, I started wondering if we could abandon those debts and redesign it ground-up with the on-demand approach in mind, what would we get?</p>
<h2>Introducing UnoCSS</h2>
<p><a href="https://github.com/antfu/unocss"><strong>UnoCSS</strong></a> - the instant atomic CSS engine with maximum performance and flexibility.</p>
<p>It started with some random experiments during my national holiday. With the mind of on-demand and the flexibility that I would expect as a user, the experiments turned out to be very good to me in many ways.</p>
<h3>The Engine</h3>
<p>UnoCSS is an <strong>engine</strong> instead of a <strong>framework</strong> because there are <strong>no core utilities</strong> - all the functionalities are provided via presets or inline configurations.</p>
<p>We are imagining UnoCSS being able to simulate the functionalities of most of the existing atomic CSS frameworks. And possibly have been used as the engine to create some new atomic CSS frameworks! For example:</p>
<pre><code class="language-ts">import UnocssPlugin from '@unocss/vite'

// the following presets do not exist at this moment,
// contribution welcome!
import PresetTachyons from '@unocss/preset-tachyons'
import PresetBootstrap from '@unocss/preset-bootstrap'
import PresetTailwind from '@unocss/preset-tailwind'
import PresetWindi from '@unocss/preset-windi'
import PresetAntfu from '@antfu/oh-my-cool-unocss-preset'

export default {
  plugins: [
    UnocssPlugin({
      presets: [
        // PresetTachyons,
        PresetBootstrap,
        // PresetTailwind,
        // PresetWindi,
        // PresetAntfu

        // pick one... or multiple!
      ]
    })
  ]
}
</code></pre>
<p>Let's take a look at how it made them possible:</p>
<h3>Intuitive &amp; Fully Customizable</h3>
<p>The main goals of UnoCSS are intuitiveness and customization. It allows you to define your own utilities literally in seconds.</p>
<p>Here is a quick guide through:</p>
<h6>Static Rules</h6>
<p>Atomic CSS might come huge in terms of the amount. It's important to have the rules definition straightforward and easy to read. To create a custom rule for UnoCSS, you can write it as follows:</p>
<pre><code class="language-ts">rules: [
  ['m-1', { margin: '0.25rem' }]
]
</code></pre>
<p>Whenever <code>m-1</code> is detected in users' codebase, the following CSS will be generated:</p>
<pre><code class="language-css">.m-1 { margin: 0.25rem; }
</code></pre>
<h6>Dynamic Rules</h6>
<p>To make it dynamic, change the matcher to a RegExp and the body to a function:</p>
<pre><code class="language-ts">rules: [
  [/^m-(\d)$/, ([, d]) =&gt; ({ margin: `${d / 4}rem` })],
  [/^p-(\d)$/, (match) =&gt; ({ padding: `${match[1] / 4}rem` })],
]
</code></pre>
<p>The first argument of the body function is the match result, so you can destructure it to get the RegExp matched groups.</p>
<p>For example, with the usage:</p>
<pre><code class="language-html">&lt;div class=&quot;m-100&quot;&gt;
  &lt;button class=&quot;m-3&quot;&gt;
    &lt;icon class=&quot;p-5&quot; /&gt;
    My Button
  &lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>the corresponding CSS will be generated:</p>
<pre><code class="language-css">.m-100 { margin: 25rem; }
.m-3 { margin: 0.75rem; }
.p-5 { padding: 1.25rem; }
</code></pre>
<p>That's it. You only need to add more utilities using the same pattern, and now you got your own atomic CSS running!</p>
<h3>Variants</h3>
<p><a href="https://windicss.org/utilities/variants.html#variants">Variants</a> in UnoCSS are also simple yet powerful. Here are a few examples:</p>
<pre><code class="language-ts">variants: [
  // support `hover:` for all rules
  {
    match: s =&gt; s.startsWith('hover:') ? s.slice(6) : null,
    selector: s =&gt; `${s}:hover`,
  },
  // support `!` prefix to make the rule important
  {
    match: s =&gt; s.startsWith('!') ? s.slice(1) : null,
    rewrite: (entries) =&gt; {
      // append ` !important` to all css values
      entries.forEach(e =&gt; e[1] += ' !important')
      return entries
    },
  }
],
</code></pre>
<p>The configurations of variants could be a bit advanced. Due to the length of the post, I will skip the detailed explanation here, you can refer to <a href="https://github.com/antfu/unocss#custom-variants">the docs</a> for more details.</p>
<h3>Presets</h3>
<p>Now you can pack your custom rules and variants into presets and share them with others - or create even your own atomic CSS framework on top of UnoCSS!</p>
<p>Meanwhile, we ship with <a href="https://github.com/antfu/unocss#presets">a few presets</a> for you to get your hands on quickly.</p>
<p>One thing worth mentioning is the default <a href="https://github.com/antfu/unocss/tree/main/packages/preset-uno"><code>@unocss/preset-uno</code></a> preset (<strong>still experimental</strong>) is a common superset of the popular utilities-first framework, including Tailwind CSS, Windi CSS, Bootstrap, Tachyons, etc.</p>
<p>For example, both <code>ml-3</code> (Tailwind), <code>ms-2</code> (Bootstrap), <code>ma4</code> (Tachyons), <code>mt-10px</code> (Windi CSS) are valid.</p>
<pre><code class="language-css">.ma4 { margin: 1rem; }
.ml-3 { margin-left: 0.75rem; }
.ms-2 { margin-inline-start: 0.5rem; }
.mt-10px { margin-top: 10px; }
</code></pre>
<p><a href="https://github.com/antfu/unocss/tree/main/packages/preset-uno">Learn more about the default preset</a>.</p>
<h3>Flexibility</h3>
<p>Till now, we are all showcasing how you can use UnoCSS to mimic the behavior of Tailwind - while we made it really easy to mimic Tailwind by your own, that alone probably won't make much difference on the user side.</p>
<p>Let's unleash the true power of UnoCSS:</p>
<h6>Attributify Mode</h6>
<p><a href="https://windicss.org/posts/v30.html#attributify-mode">The Attributify Mode</a> is one of the beloved features of Windi CSS. It helps you better organize and group your utilities by using attributes.</p>
<p>It turns your Tailwind code from this:</p>
<pre><code class="language-html">&lt;button class=&quot;bg-blue-400 hover:bg-blue-500 text-sm text-white font-mono font-light py-2 px-4 rounded border-2 border-blue-200 dark:bg-blue-500 dark:hover:bg-blue-600&quot;&gt;
  Button
&lt;/button&gt;
</code></pre>
<p>to:</p>
<pre><code class="language-html">&lt;button 
  bg=&quot;blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600&quot;
  text=&quot;sm white&quot;
  font=&quot;mono light&quot;
  p=&quot;y-2 x-4&quot;
  border=&quot;2 rounded blue-200&quot;
&gt;
  Button
&lt;/button&gt;
</code></pre>
<p>Not only this provide better organization by the categories, but also saves you the repetitive typing of the same prefixes.</p>
<p>In UnoCSS, we implemented the Attributify Mode by using only <a href="https://github.com/antfu/unocss/blob/main/packages/preset-attributify/src/variant.ts"><strong>one variant</strong></a> and <a href="https://github.com/antfu/unocss/blob/main/packages/preset-attributify/src/extractor.ts"><strong>one extractor</strong></a> with <strong>less than 100 lines of code</strong> in total! More importantly, it directly works for any custom rules you have defined!</p>
<p>In addition Windi's Attributify Mode, we also support valueless attributes with a few lines of changes:</p>
<pre><code class="language-html">&lt;div class=&quot;m-2 rounded text-teal-400&quot; /&gt;
</code></pre>
<p>now can be</p>
<pre><code class="language-html">&lt;div m-2 rounded text-teal-400 /&gt;
</code></pre>
<p>Attributify Mode is provided via preset <a href="https://github.com/antfu/unocss/blob/main/packages/preset-attributify"><code>@unocss/preset-attributify</code></a>, refer to its docs for detailed usages.</p>
<h6>Pure CSS Icons</h6>
<p>If you've ever read my previous post <a href="/posts/journey-with-icons-continues">Journey with Icons Continues</a> you must know that I am very enthusiastic about icons and actively researching for icons solutions. This time with UnoCSS's flexibility, we could even have pure CSS icons! Yes, you read me, <strong>it's purely in CSS and zero JavaScript</strong>! Let's just see how it looks like:</p>
<pre><code class="language-html">&lt;!-- A basic anchor icon from Phosphor icons --&gt;
&lt;div class=&quot;i-ph-anchor-simple-thin&quot; /&gt;
&lt;!-- An orange alarm from Material Design Icons --&gt;
&lt;div class=&quot;i-mdi-alarm text-orange-400 hover:text-teal-400&quot; /&gt;
&lt;!-- A large Vue logo --&gt;
&lt;div class=&quot;i-logos-vue text-3xl&quot; /&gt;
&lt;!-- Sun in light mode, Moon in dark mode, from Carbon --&gt;
&lt;button class=&quot;i-carbon-sun dark:i-carbon-moon&quot; /&gt;
&lt;!-- Twemoji of laugh, turns to tear on hovering --&gt;
&lt;div class=&quot;i-twemoji-grinning-face-with-smiling-eyes hover:i-twemoji-face-with-tears-of-joy&quot; /&gt;
</code></pre>
<div flex gap-2 text-4xl p-2 mt4>
  <!-- A basic anchor icon from Phosphor icons -->
  <div class="i-ph-anchor-simple-thin" />
  <!-- An orange alarm from Material Design Icons -->
  <div class="i-mdi-alarm text-orange-400 hover:text-teal-400" />
  <!-- A large Vue logo -->
  <div class="i-logos-vue transform transition-800 hover:rotate-180" />
  <!-- Sun in light mode, Moon in dark mode, from Carbon -->
  <button class="i-carbon-sun dark:i-carbon-moon" @click="toggleDark()"/>
  <!-- Twemoji of laugh, turns to tear on hovering -->
  <div class="i-twemoji-grinning-face-with-smiling-eyes hover:i-twemoji-face-with-tears-of-joy" /> 
  <div text-base my-auto flex><div i-carbon-arrow-left my-auto mr-1 /> Hover it</div>
</div>
<script setup>
import { isDark } from '/~/logics'

function toggleDark() {
  isDark.value = !isDark.value
}
</script>
<p>Combining with variants, you can even switch icons based on hovering state or even color schema. Play with the demo above and see. Thanks to the awesome <a href="https://iconify.design/">Iconify</a> project, you have access to over <strong>10,000 icons</strong> from over 100 popular icon sets <strong>on-demand</strong>.</p>
<p>Once again, this feature is written with less than 100 lines of code. Check out the preset's implementation <a href="https://github.com/antfu/unocss/blob/main/packages/preset-icons"><code>@unocss/preset-icons</code></a> to learn the magic!</p>
<blockquote>
<p>Update: Read my new post <a href="/posts/icons-in-pure-css">Icons in Pure CSS</a> to learn more about it!</p>
</blockquote>
<p>I hope these presets can give you a general idea of how flexible UnoCSS is. Given it's still in a very early stage, there are many possibilities for us to explore.</p>
<h3>Scoping</h3>
<p>One other problem that I have faced when using Tailwind/Windi is the preflight. Preflight resets the native elements and provide some fallback for CSS variables, it's great when developing a new app that uses Tailwind/Windi solely, but when you want to have them work with other UI frameworks, or share some components using Tailwind utilities, the preflight often introduce many conflicts that break your existing UI.</p>
<p>So UnoCSS took another aggressive step by not supporting preflights. Instead, it left the control of CSS resetting fully to users (or frameworks on top of UnoCSS) to use the one that fits their needs (Normalize.css, Reset.css, or UI frameworks' resetting, etc.)</p>
<p>This also allows UnoCSS to have more possibilities on CSS Scoping. For example, we have an experimental <code>scoped-vue</code> mode on the Vite plugin to generate scoped styles for each component so you can safely ship them as a component library using atomic CSS without worry about conflicting with users' CSS. For example:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;m-2 rounded&quot;&gt;&lt;slot&gt;&lt;/div&gt;
&lt;template&gt;

&lt;!-- the following will be inject in the bundler --&gt;
&lt;style scoped&gt;
.m-2{margin:0.5rem;}
.rounded{border-radius:0.25rem;}
&lt;/style&gt;
</code></pre>
<p>We are also experimenting with more possibilities like Web Components support, CSS code-splitting for MPA, module-level CSS scoping, etc.</p>
<h2>Performance</h2>
<p>Given all the flexibility and imagination UnoCSS brings, I would frankly think performance can be a less important thing to care about. Just out of curiosity, I wrote <a href="https://github.com/antfu/unocss/tree/main/bench">a simple benchmark</a> to compare the performances. And surprisingly, here is the result:</p>
<pre><code class="language-yaml">10/21/2021, 2:17:45 PM
1656 utilities | x50 runs

none                            8.75 ms /    0.00 ms 
unocss       v0.0.0            13.72 ms /    4.97 ms (x1.00)
windicss     v3.1.9           980.41 ms /  971.66 ms (x195.36)
tailwindcss  v3.0.0-alpha.1  1258.54 ms / 1249.79 ms (x251.28)
</code></pre>
<p>It turns out, UnoCSS could be <strong>200x faster than Tailwind's JIT and Windi CSS</strong>. To be honest, with the on-demand approach, both Windi and Tailwind JIT are already super-fast, the performance gain in UnoCSS might not be very perceivable. However, the nearly zero overhead means you can integrate UnoCSS into your existing project to work with other frameworks as an incremental solution without worrying about the performance loss.</p>
<p>Deep down, UnoCSS did many performance optimizations. In case you wonder, here is a few of them to take away:</p>
<h3>No Parsing, No AST</h3>
<p>Internally, Tailwind relied on modifying PostCSS's AST, while Windi wrote a custom parser and AST. Given the fact that changes in utilities are not commonly expected during the development, UnoCSS generates the utilities by the very cheap string concatenation instead of introducing a whole parser and generating process. Meanwhile, UnoCSS aggressively caches to the class names with their generated CSS string, allowing it to bypass the entire matching and generating process when seeing the same utilities again.</p>
<h3>Single Pass</h3>
<p>As mentioned in the previous section, both Windi CSS and Tailwind JIT rely on the pre-scanning for the file system and use fs watcher for HMR. File IO inevitably introduces some overhead, while your build tools are actually needed to load them once again. So why don't we leverage the content that has already been read by the dev tools directly?</p>
<p>Other than the independent generator core, UnoCSS intentionally only provides Vite plugin which allows it to focus on the best possible integration with Vite.</p>
<blockquote>
<p>Updates: Now it also provides <a href="https://github.com/antfu/unocss/tree/main/packages/webpack">a Webpack plugin</a> and <a href="https://github.com/antfu/unocss/tree/main/packages/runtime">a CSS-in-JS runtime</a></p>
</blockquote>
<p>In Vite, the <code>transform</code> hook will be iterated over with all the files with their content. So we can write a plugin to collect them like:</p>
<pre><code class="language-ts">export default {
  plugins: [
    {
      name: 'unocss',
      transform(code, id) {
        // filter out the files you don't want to scan
        if (!filter(id)) return

        // scan the code (also handles invalidate on dev)
        scan(code, id)

        // we just want the content, so we don't transform the code
        return null
      },
      resolveId(id) {
        return id === VIRTUAL_CSS_ID ? id : null
      },
      async load(id) {
        // generated css is provide as a virtual module
        if (id === VIRTUAL_CSS_ID) {
          return { code: await generate() }
        }
      }
    }
  ]
}
</code></pre>
<p>Given Vite also handles the HMR and will involve the <code>transform</code> hook again of upon file changes, this allows UnoCSS to finish everything in a single pass with no duplication of file IO and fs watcher. In addition to that, with this approach, the scanning relies on the module graph instead of file globing. Meaning that only the modules that been bundled into your app will affect the generated CSS instead of any files under your folders.</p>
<p>There are a few more tricks we have done to squeeze out even more performance. I might do another post about them later, but before that, you can read the code to figure out :)</p>
<h2>Can I Use it Now?</h2>
<p>For the short answer: Yes, but with cautions.</p>
<p>UnoCSS is still in experiments. But given its simplicity, the generation result is already quite reliable. One thing you need to care about is the APIs are not finalized yet. We will indeed follow semver on releasing, but please expect changes.</p>
<p>It's not designed to be a replacement of Windi CSS or Tailwind (consider waiting for Windi CSS v4). We don't recommend migrating existing projects to UnoCSS completely. You can try it on new projects or use it as a complement along with your existing CSS framework (for example, disable default preset and use the icon preset solely for pure CSS icons, or make your custom rules).</p>
<p>Oh btw, <a href="https://github.com/antfu/antfu.me">the site you are reading</a> is now solely on UnoCSS, for you to reference :P.</p>
<p>Meanwhile, please feel free to share the presets you are making or help contribute to our default presets. We can't wait to see what you can come up with!</p>
<h2>What about Windi CSS?</h2>
<p>As a team member of Windi CSS, I am working closely with <a href="https://github.com/voorjaar">Voorjaar</a>, the creator of Windi CSS. You can think UnoCSS is an aggressive experiment from the Windi CSS team, and it's likely to be <strong>the new engine of Windi CSS v4</strong> if it goes well.</p>
<p>Windi CSS as a framework will fill the missing features like <code>@apply</code> preprocessing, IDE intelligence sense, preflights, etc., that UnoCSS as an engine intentionally won't provide. And it will also leverage the performance and the flexibility that UnoCSS offers for both core utilities and user configurations.</p>
<p>Before we work on embedding the new engine for Windi v4, a package to use UnoCSS as an extension of Windi CSS v3 (for example, have pure CSS icons) will soon be released. Stay tuned :)</p>
<h2>Thanks</h2>
<p>Appreciate the early review and feedback provided by (A-Z):</p>
<ul>
<li><a href="https://github.com/alexanderniebuhr">@alexanderniebuhr</a></li>
<li><a href="https://github.com/ElMassimo">@ElMassimo</a></li>
<li><a href="https://github.com/harlan-zw">@harlan-zw</a></li>
<li><a href="https://github.com/QC-L">@QC-L</a></li>
<li><a href="https://github.com/userquin">@userquin</a></li>
<li><a href="https://github.com/voorjaar">@voorjaar</a></li>
<li><a href="https://github.com/wheatjs">@wheatjs</a></li>
</ul>
<h2>Wrapping Up</h2>
<p>Thanks a lot for reading through! If it ever got you interested, do remember to check out the repo <a href="https://github.com/antfu/unocss"><code>antfu/unocss</code></a> for more details and play with it on the <a href="https://unocss.antfu.me/"><strong>Online Playground</strong></a>.</p>
<p>Please feel free to comment or retweet <a href="https://twitter.com/antfu7/status/1452802545118711812">this tweet</a> letting me know what you think! 🙌</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[New Ways to Vue - Vue London 2021]]></title>
            <link>https://antfu.me/posts/new-ways-to-vue-london-2021</link>
            <guid>https://antfu.me/posts/new-ways-to-vue-london-2021</guid>
            <pubDate>Wed, 20 Oct 2021 08:00:00 GMT</pubDate>
            <description><![CDATA[New Ways to Vue - Vue London 2021]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>Slides: <a href="https://antfu.me/talks/2021-10-20">PDF</a> | <a href="https://talks.antfu.me/2021/vue-london">SPA</a></p>
<p>Made with <Slidev class="inline"/>  <a href="https://github.com/slidevjs/slidev"><strong>Slidev</strong></a> - presentation slides for developers.</p>
</blockquote>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Journey with Icons Continues]]></title>
            <link>https://antfu.me/posts/journey-with-icons-continues</link>
            <guid>https://antfu.me/posts/journey-with-icons-continues</guid>
            <pubDate>Fri, 10 Sep 2021 18:00:00 GMT</pubDate>
            <description><![CDATA[My journey with icons and the solutions I made along the way]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<div class="flex gap-3 text-lg py-2">
  <tabler:code />
  <tabler:bolt />
  <tabler:triangle-square-circle />
  <tabler:confetti />
</div>
<p>About one year ago, I wrote a blog post <a href="/posts/journey-with-icons">Journey with Icons</a>, sharing the tools I have made for solving my needs on using icons in frontend projects.</p>
<p>During this period, the Vite along its community has evolved quite a lot. The mindsets of Vite have inspired many projects to come up with efficient and innovative solutions.</p>
<p>In this post, I will share the continuation of my journey with icons and the tools I have ended up with so far.</p>
<h2>PurgeIcons &amp; Its Limitations</h2>
<p><a href="https://github.com/antfu/purge-icons">PurgeIcons</a> is my first attempt to improve the loading speed of <a href="https://iconify.design/">Iconify</a> - a united icon library that allows you to use any icons for any framework. The main problem is that it's purely client-side. Even it's flexible to work with any framework, the client-side requests inevitably introduce the flash of missing icons. To solve that, I made PurgeIcons by statically scanning your icon usages and bundle them together with your app, so the Iconify runtime could load them without additional requests.</p>
<p>This solution works, but it only solves the problem partially. As the icons are bundled within JavaScript and functions outside the frameworks, it's not ideal for working with framework-specific features like server-side rendering/generation, props passing, etc. We need to find a better way of doing it.</p>
<h2>The New Solution</h2>
<p>One of the core-concept of Vite is that everything is <strong>on-demand</strong>. Modules get transpiled only when they are being requested. In this way, the Vite server starts immediately without the need to bundle your entire app. Additionally, <a href="https://vitejs.dev/guide/api-plugin.html">Vite's plugin API</a> is an extension on top of <a href="https://rollupjs.org/guide/en/#plugin-development">Rollup's plugin system</a>, which allows you to do some <a href="https://rollupjs.org/guide/en/#transform">custom transformations</a> to the modules.</p>
<p>So, if we think in Vite's way - maybe we could solve this at compile-time instead of client-side! By using <a href="https://vitejs.dev/guide/api-plugin.html#importing-a-virtual-file">virtual modules</a>, I was able to serve the icons as components <strong>on-the-fly</strong> and made it as<br>
<a href="https://github.com/antfu/unplugin-icons"><code>vite-plugin-icons</code></a> (renamed to <code>unplugin-icons</code> later on).</p>
<pre><code class="language-ts">// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    IconsPlugin()
  ]
})

function IconsPlugin() {
  return {
    name: 'vite-plugin-icons',
    // tell Vite that ids start with `~icons/` are virtual files
    resolveId(id) {
      if (id.startsWith('~icons/'))
        return id
      return null
    },
    // custom logic to load the module
    load(id) {
      if (!id.startsWith('~icons/'))
        return
      const [prefix, collection, name] = id.split('/')
      // get icon data from Iconify
      const svg = getIconSVG(collection, name)
      // we compile the SVG as a Vue component
      return Vue3Compiler(svg)
    }
  }
}
</code></pre>
<p>And the usage will be like this:</p>
<pre><code class="language-html">&lt;script setup&gt;
import MdiAlarm from '~icons/mdi/alarm'
import FaBeer from '~icons/fa/beer'
import TearsOfJoy from '~/icons/twemoji/face-with-tears-of-joy'
&lt;/script&gt;

&lt;template&gt;
  &lt;MdiAlarm /&gt;
  &lt;FaBeer style=&quot;color: orange&quot;/&gt;
  &lt;TearsOfJoy/&gt;
&lt;/template&gt;
</code></pre>
<div class="flex gap-3 p-3">
<MdiAlarm />
<FaBeer style="color: orange"/>
<twemoji:face-with-tears-of-joy />
</div>
<p>You might notice the usages are pretty similar to existing solutions like <a href="https://react-icons.github.io/react-icons/">React Icons</a>. However, most of them approaching this by compiling all the icons into multiple files and distribute them as npm packages. Not only does it ships additional bytes for every icon and increases the time for compilers to parsing them, that also means you are limited to what they have offered exclusively.</p>
<p>With <code>unplugin-icons</code>, you can use any icons available in <a href="https://icones.js.org/">Iconify</a> (which is 100+ icon sets with over 10,000 icons and continue growing) by the following convention:</p>
<pre><code class="language-ts">import Icon from '~icons/[collection]/[name]'
</code></pre>
<p>You can learn more about the installation and usage on <GitHubLink repo="antfu/unplugin-icons" /></p>
<h2>Universal</h2>
<h3>Universal on Icons</h3>
<p>The unification or Icons are already done in Iconify by providing the icons in the same, normalized <a href="https://github.com/iconify/collections-json">JSON format</a>, so what if we could have it more universally available for the tools we loved?</p>
<GitHubLink repo="iconify/collections-json" />
<h3>Universal on Frameworks</h3>
<p>Initially, I was made this plugin only for Vue 3 on Vite. But since we are doing the complication on-demand, I figured out that we could actually apply for different compilers based on the frameworks users use. With that idea, now it supports using icons as components for Vue 3, Vue 2, React, Preact and Solid! (Contributions to add more is great welcome!)</p>
<pre><code class="language-ts">function Vue3Compiler(svg) { /* ... */ }
function Vue2Compiler(svg) { /* ... */ }
function JSXCompiler(svg) { /* ... */ }
function SolidCompiler(svg) { /* ... */ }
// ...add more!

function IconsPlugin({ compiler }) {
  return {
    name: 'vite-plugin-icons',
    resolveId(id) { /* ... */ },
    load(id) {
      /* ... */
      // we could apply different compilers here as needed
      return compiler(SVG)
    }
  }
}
</code></pre>
<p>With this, you can have it working in React like:</p>
<pre><code class="language-jsx">import MdiAlarm from '~icons/mdi/alarm'
import FaBeer from '~icons/fa/beer'
import TearsOfJoy from '~/icons/twemoji/face-with-tears-of-joy'

export function MyComponent() {
  return (&lt;&gt;
    &lt;MdiAlarm /&gt;
    &lt;FaBeer style=&quot;color: orange&quot;/&gt;
    &lt;TearsOfJoy/&gt;
  &lt;/&gt;)
}
</code></pre>
<h3>Universal on Build Tools</h3>
<p>In the past few weeks, I have joined <a href="https://nuxtlabs.com/">NuxtLabs</a> and worked on a universal plugin layer for our various bundling tools - <GitHubLink repo="unjs/unplugin" />. It allows you to use a unified plugin API to write plugins for Vite, Webpack, Rollup, Nuxt, Vue CLI, and more only once. To make it work, all we need to do is to change our code like:</p>
<pre><code class="language-ts">export function VitePluginIcons() {
  return {
    name: 'vite-plugin-icons',
    resolveId(id) { /* ... */ },
    load(id) { /* ... */ }
  }
}
</code></pre>
<pre><code class="language-ts">import { createUnplugin } from 'unplugin'

const unplugin = createUnplugin(() =&gt; {
  return {
    name: 'unplugin-icons',
    resolveId(id) { /* ... */ },
    load(id) { /* ... */ }
  }
})

// Use unplugin to generate plugins for different build tools
export const VitePluginIcons = unplugin.vite
export const WebpackPluginIcons = unplugin.webpack
export const RollupPluginIcons = unplugin.rollup
</code></pre>
<p>That's cool. With it, you don't need to learn each frameworks' plugin API and publish them in multiple packages - now you got one package for all of them!</p>
<GitHubLink repo="unjs/unplugin" />
<h3>Universal Solution</h3>
<p>With all the effort above, I converted my <code>vite-plugin-icons</code>, a Vite + Vue 3 specific icon plugin, to <code>unplugin-icons</code> as a universal icons solution.</p>
<p>For what I mean universal, I mean literally, you can use:</p>
<ul class="children:my-auto">
<li><span><logos:vue class="inline"/> Vue 3 + <vite-logo class="inline"/> Vite + <carbon:carbon class="inline"/> <a href="https://carbondesignsystem.com/guidelines/icons/library/" target="_blank">Carbon Icons</a></span></li>
<li><span><logos:react class="inline"/> React + <logos:nextjs-icon class="inline filter dark:invert"/> Next.js + <mdi:material-design class="inline"/> <a href="https://materialdesignicons.com/" target="_blank">Material Design Icons</a></span></li>
<li><span><logos:vue class="inline"/> Vue 2 + <logos:nuxt-icon class="inline"/> Nuxt.js + <uim:circle-layer class="inline"/> <a href="https://iconscout.com/unicons" target="_blank">Unicons</a></span></li>
<li><span><logos:preact class="inline"/> React + <logos:webpack class="inline"/> Webpack + <twemoji:star-struck class="inline"/> <a href="https://github.com/twitter/twemoji" target="_blank">Twemoji</a></span></li>
<li><span><solid-logo class="inline"/> Solid + <vite-logo class="inline"/> Vite + <tabler-writing-sign class="inline"/> <a href="https://tabler-icons.io/" target="_blank">Tabler</a></span></li>
<li><span><logos:javascript class="inline"/> Vanila + <logos:rollup class="inline"/> Rollup + <bx:bx-planet class="inline"/> <a href="https://github.com/atisawd/boxicons" target="_blank">BoxIcons</a></span></li>
<li><span><logos:webcomponents class="inline"/> Web Components + <vite-logo class="inline"/> Vite + <ant-design:carry-out-twotone class="inline"/> <a href="https://github.com/ant-design/ant-design-icons" target="_blank">Ant Design Icons</a></span></li>
<li><span><logos:svelte-icon class="inline"/> Svelte + <logos:svelte-icon class="inline"/> SvelteKit + <eos-icons:installing class="inline"/> <a href="https://gitlab.com/SUSE-UIUX/eos-icons" target="_blank">EOS Icons</a></span></li>
<li><span><line-md:question-circle class="inline"/> Any + <mdi:progress-question class="inline"/> Any + <ph:circle-wavy-question-duotone class="inline"/> Any</span></li>
</ul>
<p>...really, you made the combinations!</p>
<p>Get it now 👇</p>
<GitHubLink repo="antfu/unplugin-icons" />
<h2>One More Thing</h2>
<p>Oh, you are still here. So I guess you are looking for something even further.</p>
<p>As you might notice, whenever you want to use an icon, you need to import it first, name it, and then use it. In this case, the icon name has been repeated at least three times. For example:</p>
<h6>Vue</h6>
<pre><code class="language-html">&lt;script setup&gt;
import MdiAlarm from '~icons/mdi/alarm'
&lt;/script&gt;

&lt;template&gt;
  &lt;MdiAlarm /&gt;
&lt;/template&gt;
</code></pre>
<h6>React</h6>
<pre><code class="language-jsx">import MdiAlarm from '~icons/mdi/alarm'

export function MyComponent() {
  return (
    &lt;div&gt;
      &lt;MdiAlarm /&gt;
    &lt;div/&gt;
  )
}
</code></pre>
<p>So yes, we might need a better way to do this.</p>
<h3>Auto-importing</h3>
<p>Inspired by <GitHubLink repo="nuxt/components" /> which registers components under your <code>./components</code> directory automatically, I made <GitHubLink repo="antfu/unplugin-vue-components" /> (yes, another unplugin!) do to compile-time components auto-importing on-demand. With the on-demand natural, we could even make the components resolving on-demand. What a perfect complement for our icon solution!</p>
<p><code>unplugin-vue-components</code> provide the options <code>resolvers</code> to provide custom functions to resolve where the components should be imported from.</p>
<p>Here is an example configuration for Vite (since both of them are unplugins, you can also use them for Webpack and Rollup):</p>
<pre><code class="language-ts">// vite.config.js
import { defineConfig } from 'vite'
import Icons from 'unplugin-icons/vite'
import Components from 'unplugin-vue-components/vite'
import IconsResolver from 'unplugin-icons/resolver'

export default defineConfig({
  plugins: [
    /* ... */
    Icons(),
    Components({
      resolvers: [
        IconsResolver({
          // to avoid naming conflicts
          // a prefix can be specified for icons
          prefix: 'i'
        })
      ]
    })
  ]
})
</code></pre>
<p>Then we can use them directly in our templates, no more imports and repeats (and you can change the icons much easier as you don't need to update in three places):</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;!-- both PascalCase and dash-case are supported by Vue --&gt;
  &lt;IMdiAlarm /&gt;
  &lt;i-fa-beer style=&quot;color: orange&quot;/&gt;
&lt;/template&gt;
</code></pre>
<p>Isn't it perfect?!</p>
<p>Learn more: <GitHubLink repo="antfu/unplugin-vue-components" /></p>
<blockquote>
<p>Auto-import integrations for <code>@nuxt/components</code> is in progress.</p>
</blockquote>
<h4>Auto-importing for JSX</h4>
<p>Oh, I almost forgot about it. Since JSX is more like plain JavaScript in some ways and JSX components are just functions or classes, the thing is actually a bit simpler. For that, we can use another unplugin I made - <GitHubLink repo="antfu/unplugin-auto-import" />.</p>
<p>For some background here, <code>unplugin-auto-import</code> is a compile-time successor of <GitHubLink repo="antfu/vue-global-api" /> to improve DX of Vue Composition API (directly use of <code>ref</code>, <code>computed</code>, etc.).</p>
<p>With the expansion to a general auto-importing solution for any API sets, it's also possible to do auto-importing for JSX components. in <code>unplugin-auto-import</code>, we implement the same resolver interface for it.</p>
<pre><code class="language-ts">// vite.config.js
import { defineConfig } from 'vite'
import Icons from 'unplugin-icons/vite'
import AutoImport from 'unplugin-auto-import/vite'
import IconsResolver from 'unplugin-icons/resolver'

export default defineConfig({
  plugins: [
    /* ... */
    Icons({
      compiler: 'jsx'
    }),
    AutoImport({
      imports: [
        'react' // preset for react
      ],
      resolvers: [
        IconsResolver({
          prefix: 'Icon',
          extension: 'jsx'
        })
      ]
    })
  ]
})
</code></pre>
<p>Here is your React component, and you are welcome :)</p>
<pre><code class="language-ts">export function MyComponent() {
  return (
    &lt;&gt;
      &lt;IconMdiAlarm /&gt;
      &lt;IconFaBeer style=&quot;color: orange&quot;/&gt;
    &lt;/&gt;
  )
}
</code></pre>
<h2>Recap</h2>
<p>For a quick summary, here is the list of projects mentioned for these solutions:</p>
<ul>
<li><GitHubLink repo="unjs/unplugin" /> - Unified plugin system for Vite, Rollup, Webpack, and more.</li>
<li><GitHubLink repo="antfu/unplugin-icons" /> - Access thousands of icons as components on-demand.</li>
<li><GitHubLink repo="antfu/unplugin-vue-components" /> - On-demand components auto importing.</li>
<li><GitHubLink repo="antfu/unplugin-auto-import" /> - Auto import APIs on-demand.</li>
</ul>
<p>Meanwhile, you might also find these tools from my last journey helpful:</p>
<ul>
<li><GitHubLink repo="antfu/icones" /> - Icon Explorer for Iconify with Instant searching and exporting.</li>
<li><GitHubLink repo="antfu/vscode-iconify" /> - Iconify IntelliSense for VS Code.</li>
</ul>
<p>If you enjoy them, you might also want to check my Vue + Vite starter template with them configured in-box.</p>
<ul>
<li><GitHubLink repo="antfu/vitesse" /> - Opinionated Vite Starter Template.</li>
<li><GitHubLink repo="antfu/vitesse-lite" /> - Lightweight version of Vitesse.</li>
<li><GitHubLink repo="antfu/vitesse-webext" /> - WebExtension Vite Starter Template.</li>
<li><GitHubLink repo="antfu/vitesse-nuxt" /> - Vitesse experience for Nuxt 2 and Vue 2.</li>
</ul>
<p>Again, thanks for reading through :)</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Async with Composition API]]></title>
            <link>https://antfu.me/posts/async-with-composition-api</link>
            <guid>https://antfu.me/posts/async-with-composition-api</guid>
            <pubDate>Fri, 16 Jul 2021 08:00:00 GMT</pubDate>
            <description><![CDATA[Notes about the caveat when using async functions in Vue Composition API.]]></description>
            <content:encoded><![CDATA[<p>There is a major caveat when working with asynchronous functions in Vue Composition API, that I believe many of you have ever come across. I have acknowledged it for a while from somewhere, but every time I want to have a detailed reference and share to others, I can't find it's documented anywhere. So, I am thinking about writing one, with a detailed explanation while sorting out the possible solutions for you.</p>
<ul>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#the-mechanism">The Mechanism</a></li>
<li><a href="#the-limitation">The Limitation</a></li>
<li><a href="#the-solutions">The Solutions</a></li>
</ul>
<h2>The Problem</h2>
<p>When using asynchronous <code>setup()</code>, <strong>you have to use effects and lifecycle hooks before the first <code>await</code> statement.</strong> (<a href="https://github.com/vuejs/rfcs/discussions/234">details</a>)</p>
<p>For example:</p>
<pre><code class="language-ts">import { ref, watch, onMounted, onUnmounted } from 'vue'

export default defineAsyncComponent({
  async setup() {
    const counter = ref(0)

    watch(counter, () =&gt; console.log(counter.value))

    // OK!
    onMounted(() =&gt; console.log('Mounted'))

    // the await statement
    await someAsyncFunction() // &lt;-----------

    // does NOT work!
    onUnmounted(() =&gt; console.log('Unmounted'))

    // still works, but does not auto-dispose 
    // after the component is destroyed (memory leak!)
    watch(counter, () =&gt; console.log(counter.value * 2))
  }
})
</code></pre>
<p>After the <code>await</code> statement,</p>
<p>the following functions will be <strong>limited</strong> (no auto-dispose):</p>
<ul>
<li><code>watch</code> / <code>watchEffect</code></li>
<li><code>computed</code></li>
<li><code>effect</code></li>
</ul>
<p>the following functions will <strong>not work</strong>:</p>
<ul>
<li><code>onMounted</code> / <code>onUnmounted</code> / <code>onXXX</code></li>
<li><code>provide</code> / <code>inject</code></li>
<li><code>getCurrentInstance</code></li>
<li>...</li>
</ul>
<h2>The Mechanism</h2>
<p>Let's take the <code>onMounted</code> API as an example. As we know, <code>onMounted</code> is a hook that registers a listener when the current component gets mounted. Notice that <code>onMounted</code> (along with other composition APIs) are <strong>global</strong>, for what I mean &quot;global&quot; is that it can be imported and called anywhere - there is <strong>no local context</strong> bound to it.</p>
<pre><code class="language-ts">// local: `onMounted` is a method of `component` that bound to it
component.onMounted(/* ... */)

// global: `onMounted` can be called without context
onMounted(/* ... */)
</code></pre>
<p>So, how does <code>onMounted</code> know what component is being mounted?</p>
<p>Vue takes an interesting approach to solve this. It uses an internal variable to record the current component instance. There is a simplified code:</p>
<p>When Vue mounts a component, it stores the instance in a global variable. When hooks been called inside the setup function, it will use the global variable to get the current component instance.</p>
<pre><code class="language-js">let currentInstance = null

// (pseudo code)
export function mountComponent(component) {
  const instance = createComponent(component)

  // hold the previous instance
  const prev = currentInstance

  // set the instance to global
  currentInstance = instance

  // hooks called inside the `setup()` will have
  // the `currentInstance` as the context
  component.setup() 

  // restore the previous instance
  currentInstance = prev 
}
</code></pre>
<p>A simplified <code>onMounted</code> implementation would be like:</p>
<pre><code class="language-js">// (pseudo code)
export function onMounted(fn) {
  if (!currentInstance) {
    warn(`&quot;onMounted&quot; can't be called outside of component setup()`)
    return
  }

  // bound listener to the current instance
  currentInstance.onMounted(fn)
}
</code></pre>
<p>With this approach, as long as the <code>onMounted</code> is called inside the component <code>setup()</code>, it will be able to get the instance of the current component.</p>
<h2>The Limitation</h2>
<p>So far so good, but what's wrong with asynchronous functions?</p>
<p>The implementation would work based on the fact that JavaScript is <strong>single-threaded</strong>. Single thread makes sure the following statements will be executed right next to each other, which in other words, there is no one could accidentally modify the <code>currentInstance</code> at the same time (a.k.a. it's <a href="https://stackoverflow.com/questions/52196678/what-are-atomic-operations-for-newbies">atomic</a>).</p>
<pre><code class="language-ts">currentInstance = instance
component.setup() 
currentInstance = prev 
</code></pre>
<p>The situation changes when the <code>setup()</code> is asynchronous. Whenever you <code>await</code> a promise, you can think the engine paused the works here and went to do another task. If we <code>await</code> the function, during the time period, multiple components creation will change the global variable unpredictably and end up with a mess.</p>
<pre><code class="language-ts">currentInstance = instance
await component.setup() // atomic lost
currentInstance = prev 
</code></pre>
<p>If we don't use <code>await</code> to check the instance, calling the <code>setup()</code> function will make it finish the tasks before the first <code>await</code> statement, and the rest will be executed whenever the <code>await</code> statement is resolved.</p>
<div class="grid grid-cols-2 gap-2 lt-sm:grid-cols-1">
<pre><code class="language-ts">async function setup() {
  console.log(1)
  await someAsyncFunction()
  console.log(2)
}

console.log(3)
setup()
console.log(4)
</code></pre>
<pre><code class="language-ts">// output:
3
1
4
(awaiting)
2
</code></pre>
</div>
<p>This means, there is no way for Vue to know when will the asynchronous part been called from the outside, so there is also no way to bound the instance to the context.</p>
<h2>The Solutions</h2>
<p>This is actually a limitation of JavaScript itself, unless we have some new proposal to open the gate on the language level, we have to live with it.</p>
<p>But to work around it, I have collected a few solutions for you to choose from based on your needs.</p>
<h3>Remember the Caveat and Avoid It</h3>
<p>This is, of course, an obvious &quot;solution&quot;. You can try to move your effect and hooks before the first <code>await</code> statement and carefully remember not to have them after that again.</p>
<p>Luckily, if you are using ESLint, you can have the <a href="https://eslint.vuejs.org/rules/no-watch-after-await.html"><code>vue/no-watch-after-await</code></a> and <a href="https://eslint.vuejs.org/rules/no-lifecycle-after-await.html"><code>vue/no-lifecycle-after-await</code></a> rules from <a href="https://eslint.vuejs.org/"><code>eslint-plugin-vue</code></a> enabled so it could warn you whenever you made some mistakes (they are enabled by default within the plugin presets).</p>
<h3>Wrap the Async Function as &quot;Reactive Sync&quot;</h3>
<p>In some situations, your logic might be relying on the data that fetched asynchronously. In this way, you could consider using the <a href="/posts/composable-vue-vueday-2021#async-to-sync">trick I have shared on VueDay 2021</a> to <strong>turn your async function into a sync reactive state</strong>.</p>
<pre><code class="language-ts">const data = await fetch('https://api.github.com/').then(r =&gt; r.json())

const user = data.user
</code></pre>
<pre><code class="language-ts">const data = ref(null)

fetch('https://api.github.com/')
  .then(r =&gt; r.json())
  .then(res =&gt; data.value = res)

const user = computed(() =&gt; data?.user)
</code></pre>
<p>This approach make the &quot;connections&quot; between your logic to resolve first, and then reactive updates when the asynchronous function get resolved and filled with data.</p>
<p>There is also some more general utilities for it from <a href="https://vueuse.org/">VueUse</a>:</p>
<h4><a href="https://vueuse.org/useAsyncState"><code>useAsyncState</code></a></h4>
<pre><code class="language-ts">import { useAsyncState } from '@vueuse/core'

const { state, ready } = useAsyncState(async () =&gt; {
  const { data } = await axios.get('https://api.github.com/')
  return { data }
})

const user = computed(() =&gt; state?.user)
</code></pre>
<h4><a href="https://vueuse.org/useFetch"><code>useFetch</code></a></h4>
<pre><code class="language-ts">import { useFetch } from '@vueuse/core'

const { data, isFetching, error } = useFetch('https://api.github.com/')

const user = computed(() =&gt; data?.user)
</code></pre>
<h3>Explicitly Bound the Instance</h3>
<p>Lifecycle hooks actually accept a second argument for setting the instance explicitly.</p>
<pre><code class="language-ts">export default defineAsyncComponent({
  async setup() {
    // get and hold the instance before `await`
    const instance = getCurrentInstance()

    await someAsyncFunction() // &lt;-----------

    onUnmounted(
      () =&gt; console.log('Unmounted'),
      instance // &lt;--- pass the instance to it
    )
  }
})
</code></pre>
<p>However, the downside is that this solution <strong>does not work</strong> with <code>watch</code> / <code>watchEffect</code> / <code>computed</code> / <code>provide</code> / <code>inject</code> as they does not accept the instance argument.</p>
<p>To get the effects work, you could use the <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md"><code>effectScope</code> API</a> in the upcoming Vue 3.2.</p>
<pre><code class="language-ts">import { effectScope } from 'vue'

export default defineAsyncComponent({
  async setup() {
    // create the scope before `await`, so it will be bond to the instance
    const scope = effectScope()

    const data = await someAsyncFunction() // &lt;-----------

    scope.run(() =&gt; {
      /* Use `computed`, `watch`, etc. ... */
    })

    // the lifecycle hooks will not be available here,
    // you will need to combine it with the previous snippet
    // to have both lifecycle hooks and effects works.
  }
})
</code></pre>
<h3>Compile-time Magic!</h3>
<p>In the recent <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md"><code>&lt;script setup&gt;</code> proposal</a> update, a new <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md#top-level-await">compile-time magic</a> is introduced.</p>
<p>The way it works is to inject a script after each <code>await</code> statement for restoring the current instance state.</p>
<pre><code class="language-html">&lt;script setup&gt;
const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())
&lt;/script&gt;
</code></pre>
<pre><code class="language-js">import { withAsyncContext } from 'vue'

export default {
  async setup() {
    let __temp, __restore

    const post =
      (([__temp, __restore] = withAsyncContext(() =&gt;
        fetch(`/api/post/1`).then((r) =&gt; r.json())
      )),
      (__temp = await __temp),
      __restore(),
      __temp)

    // current instance context preserved
    // e.g. onMounted() will still work.

    return { post }
  }
}
</code></pre>
<p>With it, the async functions will <strong>just work</strong> when using with <code>&lt;script setup&gt;</code>. The only shame is it does not work outside of <code>&lt;script setup&gt;</code>.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[About Yak Shaving]]></title>
            <link>https://antfu.me/posts/about-yak-shaving</link>
            <guid>https://antfu.me/posts/about-yak-shaving</guid>
            <pubDate>Wed, 19 May 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<blockquote>
<p><a href="/posts/about-yak-shaving-zh">中文原文 Original in Chinese</a></p>
</blockquote>
<p>I recently visited Zhihu occasionally and saw many questions about how to start open source, or how to make open source projects successful. I kinda had similar doubts for a long time, so I thought that maybe I could share some of my rough views on this.</p>
<p>If you don't know me, I am a team member of Vue, Vite, wenyan-lang, WindiCSS, Intlify, and the author of VueUse, Slidev, Type Challenges and i18n Ally. I also have some small open source tools under my personal GitHub account, you can have a look at my <a href="https://antfu.me/projects">full project list</a>. Since I started doing open source in earnest almost two years ago, even though those contributions aren't that impressive, they still managed to allow me to <a href="https://twitter.com/antfu7/status/1362676666221268995">work full-time on open source development and maintenance through sponsorships</a>.</p>
<p>Many people probably gonna tell you that the success of a project depends on opportunity, marketing, branding, or documentation, ecosystem, technical innovation, code quality, etc. All of these are indeed important, but for me, the most important thing is the motivation to start a project and the drive to do it well. For me, the best way to get the power is via Yak Shaving.</p>
<h2>Yak Shaving</h2>
<p><a href="https://americanexpress.io/yak-shaving">Yak Shaving</a> refers to a series of actions when you're working on one task and then you find another task that's not finished, you tackle that one first, and while you're working on that one, you find another task to do... and so forth, so that you stray from the work that should have been done, and end up not getting nothing finished. Here is a real-world example:</p>
<blockquote>
<p>You want to bake an apple pie, so you head to the kitchen.<br><br>
In the hallway, you notice some paint chipping on the wall.<br><br>
So you walk to the hardware store for some paint.<br><br>
On the way, you pass a bakery and stop in for a cupcake.<br><br>
While eating the cupcake, you feel a pain in your mouth. It’s that cavity that you’ve been putting off.<br><br>
You pick up your phone to call the dentist to make an appointment, but you see a notification from your friend Cher, who’s having a party.<br><br>
You don’t want to show up empty-handed, so you stop for a bottle of wine…</p>
</blockquote>
<p>An example that more relevant to developers might be: You planned to write a blog today, but you found out none of the existing tools are good enough for you. Then you spend a month writing your own static website generator, but end up with the generator unfinished and forgetting about writing the blog.</p>
<p>I guess we all had similar experiences more or less. Yak Shaving usually refers to something negative, emphasizing inattentiveness or lack of clarity of purpose. But I kinda think it's also an important source of motivation for many things. When a person needs a tool, they are most motivated to solve it and make it happen. I, not coincidentally, am an obsessive Yak Shaving fan.</p>
<p>Maybe I'll share some of my stories with you to give you a better idea of what I'm trying to express:</p>
<h2>The story of how I started doing open source</h2>
<p>In my senior year of college, I went on a graduation trip to the Philippines with a group of college friends. Because of the various problems of exchanging foreign currency, an operation down to Taiwan dollars, US dollars, Philippine pesos and different exchange rates each time, making the record of public accounts and settlement very complicated. After we came back from the trip, we came up with the idea of making an app to solve this problem.</p>
<p>To make the app reach a large enough audience, multilingual internationalization is something we have to consider. As there are many foreign language departments in our college, we thought we could use our resources to get our friends to help on translating the App into multiple languages. However, it is obviously unrealistic to have foreign language students write JSON with bare hands, so we had to find something a little easier. Luckily, I found <a href="https://github.com/think2011/vscode-vue-i18n"><code>think2011/vscode-vue-i18n</code></a>, which looks great, but lacks some features we needed. So I contacted the author and got fork permission, and then, here comes the <a href="https://github.com/lokalise/i18n-ally">i18n Ally</a> project.</p>
<p>The later stage of App development coincided with the Composition API RFC of Vue 3. The new API seemed to solve many of the pain points in our development. In the spirit of experimentation, we installed the Vue 2 plugin and started to try it out. In the process of using it, we found out there are quite some functions we are commonly used, and also inspired by <a href="https://github.com/streamich/react-use"><code>react-use</code></a>, I extracted them out and made <a href="https://github.com/vueuse/vueuse">VueUse</a>.</p>
<p>Given that Vue 3 was still in Alpha at the time, and the community needs to gradually migrate from Vue 2 to Vue 3 for a long time in the future. I made VueUse intentionally as a universal library for Vue 2 and Vue 3 so that people could migrate seamlessly. The initial solution was to publish two packages for Vue 2 and 3 under different npm tags. As Vue 3 matured, more and more libraries wanted to go the same way to reduce the cost of maintaining two codebases at the same time. Then I thought, maybe I can find a general solution from VueUse, so that everyone could get benefit from it. And then, <a href="https://github.com/vueuse/vue-demi"><code>vue-demi</code></a> comes out. As a result, it also allows VueUse to publish one version that supports both Vue 2 and 3 at the same time.</p>
<p>VueUse's support for Vue 2 relies on the <a href="https://github.com/vuejs/composition-api"><code>@vue/composition-api</code></a> library, at some point, there are some inconsistencies in the plugin with the latest Vue 3 changes. Which results in VueUse's development being hampered. After a quite long time of no response to the PR from the repository, I thought I might be able to help out a bit, so I posted <a href="https://github.com/vuejs/composition-api/issues/343">an issue</a> in the repository saying I would like to volunteer myself maintaining the project. And that's also the opportunity for me to join the Vue team.</p>
<p>In the end, our App didn't work out, but I gained a lot of valuable experience solving problems and working on open source projects along the way. i18n Ally started out as a vue-i18n specific extension and now supports over 20 major frameworks, with over 60,000 downloads of VS Code. VueUse started as a simple toolset and now it becomes a GitHub Organization with 10 members and 8 ecosystem packages.</p>
<p>I could probably tell stories like these for a whole day, and behind almost every project there is such a motivation to try to solve a certain problem. After all of this harangue, the point I'm trying to make is that Yak Shaving can be a great engine for progressing when used properly.</p>
<p>And here are my methods of how to make Yak Shaving a good thing:</p>
<h2>Shave the Good Yak</h2>
<h3>Identify Problems</h3>
<p>I spent every day of my four years in college thinking if I could make an interesting open source project that everyone needed and live as a full-time open sourceror with freedom. The difference is that the four years I was thinking about how to make something that other people wanted, but later I was solving <strong>the actual problems that I encountered</strong>. As said, when you need a tool, you have the most motivation to make it. And also as a user, you know the best where the pain points and needs are. When you encounter this problem, others might have just encountered a similar one.</p>
<h3>Solve the Problem</h3>
<p>The most basic rule to start trying to solve a problem is to look for existing solutions, if the problem has been well solved, which meets your all needs, then just use it. Reinventing wheels might be a good way to learn, but since the wheels are already there, there has to be someone thinking about how to build a car, right?</p>
<p>When you find that there is no solution to the problem, or that the existing solutions don't work for you, while you have a great idea in your mind. Congratulations, you've found a great Yak.</p>
<h3>Good Enough</h3>
<p>The most important part of making Yak Shaving great is to <strong>just be good enough</strong> -- do not have too much expectation, if the idea is verified feasible, make it just good enough; if the idea does now work, don't be discouraged, just throw it away, maybe one day you can pick it back up again with new ideas. It's not necessary to be perfect at the beginning. You don't have to draw a grand blueprint or plan, you don't have to set a huge goal of how many stars or how many users - you are doing it for yourself, and make it just good enough to solve your own problems. The important thing is to not spending too much time on a single idea, and get back to what you should have been doing in time.</p>
<h3>Refine the Project</h3>
<p>As the first user of your own product, you will find a lot of things for improvement in the process of using it, go and modify it from time to time and do some improvements. If you got more time, you can add a README describing the problems you encountered and the motivation for doing the project, which may be helpful to someone who faced similar problems.</p>
<p>In the end, when using the project makes you feel that it's a pretty good idea, while you have completed the work that should have been done, you may wish to spend some time writing a document, improve the implementations, and promote a little. It's best if it has been recognized, but if not, just treat it as an exercise, and at least you've your own problems solved. If the responses went well, then someone will start to raise issues and send PRs. Which more enhancements and features coming, you will also gradually find the future direction of the project. Besides that, those changes and enhancements from the community may end up being a better solution to the problems you encountered at the beginning.</p>
<h3>Identify More Problems</h3>
<p>The way to find more problems is simple, learn more and try more. In the process of solving and improving the problem, you will likely find new problems that could potentially be solved. Issues from the community can also help you find more inspiration. Anyway, congratulations on entering the positive cycle!</p>
<h2>Wrapping Up</h2>
<p>Hopefully, this insight could give you some inspiration on solving your own problems, or making a good open source product, in one way or another.</p>
<p>I also recommend some awesome Yak Shaving masters, maybe their projects and experiences can give you some inspiration as well:</p>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a> - actively maintains 1100+ npm packages, Webpack and Babel both rely on 100+ of his packages</li>
<li><a href="https://github.com/tj">TJ Holowaychuk</a> - Author of koa, mocha, express, etc.</li>
<li><a href="https://github.com/lukeed">Luke Edwards</a> - Author of polka, uvu, klona, etc.</li>
<li><a href="https://github.com/egoist">Egoist</a> - Author of poi, cac, saber, etc.</li>
<li><a href="https://github.com/privatenumber">Hiroki Osame</a> - Author of esbuild-loader, vue-2-3, etc.</li>
</ul>
<p>Cheers, and happy hacking!</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Composable Vue - VueDay 2021]]></title>
            <link>https://antfu.me/posts/composable-vue-vueday-2021</link>
            <guid>https://antfu.me/posts/composable-vue-vueday-2021</guid>
            <pubDate>Wed, 28 Apr 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[Slides & transcript for my talk at VueDay 2021]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<blockquote>
<p>This is the transcript of my talk <strong>Composable Vue</strong> at <a href="https://2021.vueday.it/">VueDay 2021</a></p>
<p>Slides: <a href="https://antfu.me/talks/2021-04-29">PDF</a> | <a href="https://talks.antfu.me/2021/composable-vue">SPA</a></p>
<p>Recording: <a href="https://youtu.be/IMJjP6edHd0">YouTube</a></p>
<p>Made with <Slidev class="inline"/>  <a href="https://github.com/slidevjs/slidev"><strong>Slidev</strong></a> - a slides maker for developers that I am working on recently.</p>
</blockquote>
<p>My sharing today is Composable Vue, some pattens and tips that might be able to help you writing better composable logic in Vue.</p>
<h2><a href="https://vueuse.org/">VueUse</a></h2>
<p>It all started with me made this project called VueUse, which is a collection of Vue composable utilities. Initially, I was making this to share some of the functions I wrote with Vue Composition API to be used across apps. Till now, it grows much bigger with the community, we are now an organization on GitHub with 9 team members, 8 add-ons packages for different integrations like motions and document head management. We also have more than 100 functions in the core package that work for both Vue 2 and 3. I have really appreciated all the contributors and the awesome community.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vueuse/vueuse">vueuse/vueuse</a></p>
<p>In today's talk, I will share with you the patterns and tips that I have learned during developing VueUse and using it to make apps in Composition API.</p>
<h2>Composition API</h2>
<p>Let's have a quick look at the Composition API itself. BTW, please note today's talk will be a little bit advanced, which I would assume you already have a basic knowledge of what the Vue Composition API is. But don't worry if you don't, I believe you will still get some basic images of the methodology and you can also find the slides and transcript on my site after the talk.</p>
<h3>Ref vs Reactive <MarkerCore/></h3>
<p>Well, let's start with Ref and Reactive. I bet many of you have wondered the difference between them and which one should you choose.</p>
<p>You can think refs as variables and reactives as objects. When you do the assignment, one is assigning &quot;value&quot; while the other one is assigning properties. While the usage of them can really dependents on what you gonna use them, but if we really need to pick one from them, I'd say go with <code>ref</code> whenever you can.</p>
<p>With <code>ref</code>, you will need to use <code>.value</code> to access and assigning values, but this also gives you more explicit awareness of when you are tracking and triggering the reactivity system.</p>
<pre><code class="language-ts">import { ref } from 'vue'

let foo = 0
let bar = ref(0)

foo = 1
bar = 1 // ts-error
</code></pre>
<p>As you can see the example here, I actually got an error by accidentally assigning ref with a value, and here I can change the code to fix it.</p>
<pre><code class="language-ts">import { reactive } from 'vue'

const foo = { prop: 0 }
const bar = reactive({ prop: 0 })

foo.prop = 1
bar.prop = 1
</code></pre>
<p>On the other hand, when using <code>reactive</code> you actually can't tell the difference between a plain object and a reactive object without looking for the context, which could sometimes make the debugging a little bit harder.</p>
<p>Also note in reactive objects, there are several caveats you need to take care about. Like you can't do object destructure without <code>toRefs</code> otherwise they will lose the reactivity. And you will also need to wrap with a function when using with <code>watch</code> and so on, where <code>ref</code> does not have such limitations.</p>
<h3>Ref Auto Unwrapping <MarkerCore /></h3>
<p>When using with <code>refs</code>, a big obstacle that people facing is the annoying <code>.value</code>. But actually, in many cases, you can omit it and make your code looks cleaner.</p>
<pre><code class="language-ts">const counter = ref(0)

watch(counter, count =&gt; {
  console.log(count) // same as `counter.value`
})
</code></pre>
<p>The <code>watch</code> function accepts ref as the watch source directly, and it will return the unwrapped new value of the ref in the callback. So in this case, there is zero <code>.value</code> needed.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;counter += 1&quot;&gt;
    Counter is {\{ counter }}
  &lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>The other one is the nature of Vue, in the template, all the refs are auto unwrapped, even assignments!</p>
<pre><code class="language-ts">import { ref, reactive } from 'vue'
const foo = ref('bar')
const data = reactive({ foo, id: 10 })
data.foo // 'bar'
</code></pre>
<p>And whenever you feel like to better work with objects, you can pass the ref into the reactive object, and when you access the property, reactive will unwrap the ref automatically for you. Changes to the original ref will also reflect to the reactive object!</p>
<h3><code>unref</code> - Oppsite of Ref <MarkerCore /></h3>
<p><code>unref</code> is another Composition API I would like to introduce. As the name <code>unref</code> sounds, it's kinda the opposite of ref. While the <code>ref()</code> function takes a value and turns it into a ref, <code>unref()</code> takes a ref and returns its value.</p>
<pre><code class="language-ts">function unref&lt;T&gt;(r: Ref&lt;T&gt; | T): T {
  return isRef(r) ? r.value : r
}
</code></pre>
<p>The interesting part of it is that if you pass a plain value to <code>unref</code> it will return the value as-is to you, you can see the implementation is basically this.</p>
<pre><code class="language-ts">import { unref, ref } from 'vue'

const foo = ref('foo')
unref(foo) // 'foo'

const bar = 'bar'
unref(bar) // 'bar'
</code></pre>
<p>This is not a big feature, but a good tip to unify your logic which I will show you soon</p>
<h2>Patterns &amp; Tips</h2>
<p>That's the tips for using ref and reactive. Here I'd like to share with you some patterns of writing composable functions.</p>
<h2>What's composable Functions</h2>
<p>So what's composable functions?</p>
<p>It's actually kind of hard to give a proper definition, but I'd think it's like sets for reusable logic to make your code better organized, and separate the concerns.</p>
<pre><code class="language-ts">export function useDark(options: UseDarkOptions = {}) {
  const preferredDark = usePreferredDark()         // &lt;--
  const store = useStorage('vueuse-dark', 'auto')  // &lt;--

  return computed&lt;boolean&gt;({
    get() {
      return store.value === 'auto'
        ? preferredDark.value
        : store.value === 'dark'
    },
    set(v) {
      store.value = v === preferredDark.value 
        ? 'auto' : v ? 'dark' : 'light'
    },
  })
}
</code></pre>
<p>Here is an example, the <code>useDark</code> function in VueUse is provided as a simple toggle to enable or disable the dark mode for apps. There are actually two variables involved, one is the system's preference and one is users' manual overrides. System preference can be got using media queries, while we would also need to use localStorage to read and store the user's preference of different modes.</p>
<DarkToggleButton/>
<p>As you can see in this code snippet, I have used two other composable functions <a href="https://vueuse.org/usePreferredDark"><code>usePreferredDark</code></a> and <a href="https://vueuse.org/useStorage"><code>useStorage</code></a>, they will return two refs that reflecting on their states. Detailed things like monitoring the media query changes, the timing to read and write the storage are left to them. And all I need to do is logically composing their relationship into a single ref.</p>
<p>You can see the full code or directly use it in VueUse with the link below.</p>
<VueUseFn name="useDark"/>
<h3>Think as &quot;Connections&quot;</h3>
<p>The first methodology I want to share today is to think as &quot;connections&quot;. Unlike hooks in React that will run on each updates, the <code>setup()</code> function in Vue only runs <strong>once</strong> on component initialization, to construct the relations between your state and logic.</p>
<p>You can think the equations in mathematics, where the left hand side and right hand side are always equal. Here we have <code>z=x^2+y^2</code>, while <code>x</code> and <code>y</code> are independent variables, and <code>z</code> is a controlled variables relying on <code>x</code> and <code>y</code>. Whenever I changed any of them, <code>z</code> will be updated accordingly (DEMO). Which is also similar to the formula in spreadsheets.</p>
<p>So in composable functions, we could think arguments are input and the returns as the output. The output should be able to reflect on input changes automatically. A bit complicated? I will walk with you on that later with examples.</p>
<h3>One Thing at a Time</h3>
<p>Another aspect is to do one thing at a time - which is the same as how you write any code. No need for me to spend too much time on this, but basically they are listed here.</p>
<ul>
<li>Extract duplicated logics into composable functions</li>
<li>Have meaningful names</li>
<li>Consistent naming conversions - <code>useXX</code> <code>createXX</code> <code>onXX</code></li>
<li>Keep function small and simple</li>
<li>&quot;Do one thing, and do it well&quot;</li>
</ul>
<p>Note it's also important to have a consistent naming conversion, like prefixed with <code>useXX</code> or <code>createXX</code> and so on to make those composable functions distinguishable from other functions.</p>
<h3>Passing Ref as Arguments</h3>
<p>Alright, let's start our first pattern today - Passing refs as arguments.</p>
<pre><code class="language-ts">function add(a: number, b: number) {
  return a + b
}
</code></pre>
<pre><code class="language-ts">let a = 1
let b = 2

let c = add(a, b) // 3
</code></pre>
<p>Here we have a plain add function that sums up the two arguments <code>a</code> and <code>b</code>. You can also see the example on the right.</p>
<pre><code class="language-ts">function add(a: Ref&lt;number&gt;, b: Ref&lt;number&gt;) {
  return computed(() =&gt; a.value + b.value)
}
</code></pre>
<pre><code class="language-ts">const a = ref(1)
const b = ref(2)

const c = add(a, b)
c.value // 3
</code></pre>
<p>And then we can make this function accepting refs, and return a computed ref with their sum. Then we can pass the refs to it as we normally would with plain values. The difference here is that the returned value is also a ref, but it will always be up-to-date with the ref <code>a</code> and <code>b</code>.</p>
<pre><code class="language-ts">function add(
  a: Ref&lt;number&gt; | number,
  b: Ref&lt;number&gt; | number
) {
  return computed(() =&gt; unref(a) + unref(b))
}
</code></pre>
<pre><code class="language-ts">const a = ref(1)

const c = add(a, 5)
c.value // 6
</code></pre>
<p>And remember the <code>unref</code> function we mentioned before? We can actually make this function more flexible, by accepting both refs and plain values. And use <code>unref</code> to get their values. We can also make the addition possible between a ref and a value.</p>
<h3>MaybeRef</h3>
<pre><code class="language-ts">type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T
</code></pre>
<p>Here is a simple TypeScript's type helper called <code>MaybeRef</code> that we have used a lot in VueUse. It's a union of generic <code>T</code> and <code>Ref&lt;T&gt;</code>.</p>
<pre><code class="language-ts">export function useTimeAgo(
  time: Date | number | string | Ref&lt;Date | number | string&gt;,
) {
  return computed(() =&gt; someFormating(unref(time)))
}
</code></pre>
<pre><code class="language-ts">import { computed, unref, Ref } from 'vue'

type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T

export function useTimeAgo(
  time: MaybeRef&lt;Date | number | string&gt;,
) {
  return computed(() =&gt; someFormating(unref(time)))
}
</code></pre>
<p>In this case, we have the function useTimeAgo that accepts a wide range of Date-like types as an argument. Normally if you want to accept refs, you would need to write them again as Ref versions. With this helper, you can make the type shorter and more readable (change code). A cool point it that this works great with <code>unref</code>, it can infer the correct type for <code>MaybeRef</code>.</p>
<h3>Make it Flexible <MarkerPattern /></h3>
<p>Think your functions like LEGO, there should have many different ways of composing them for different needs.</p>
<pre><code class="language-ts">import { useTitle } from '@vueuse/core'

const title = useTitle()

title.value = 'Hello World'
// now the page's title changed
</code></pre>
<p>Here we take <code>useTitle</code> function from VueUse as an example. Basically when you call it, you will get a special ref that binds to your page's title. Whenever you change the ref's value, the page's title will also be updated. Similarly, when the page's title changed externally, the change will also be reflect to the ref's value.</p>
<p>Looks good, right? But It creates a new ref whenever you call it. To make it more flexible, we can actually bind an existing ref, even computed!</p>
<pre><code class="language-ts">import { ref, computed } from 'vue'
import { useTitle } from '@vueuse/core'

const name = ref('Hello')
const title = computed(() =&gt; {
  return `${name.value} - World`
})

useTitle(title) // Hello - World

name.value = 'Hi' // Hi - World
</code></pre>
<p>Here you can see, I constructed a computed with a ref, when I change the source ref, the computed get re-evaluated so as the page's title.</p>
<h3><code>useTitle</code> <Marker class="text-blue-400">Case</Marker></h3>
<p>You must be wondering how could this be implemented. Let's take a look at a simplified version of it.</p>
<pre><code class="language-ts">import { ref, watch } from 'vue'
import { MaybeRef } from '@vueuse/core'

export function useTitle(
  newTitle: MaybeRef&lt;string | null | undefined&gt;
) {
  const title = ref(newTitle || document.title) // &lt;-- 1

  watch(title, (t) =&gt; { // &lt;-- 2
    if (t != null)
      document.title = t
  }, { immediate: true })

  return title
}
</code></pre>
<p>It's actually only two statements! How?</p>
<p>At the first line, unified the ref from the user, or create a new one. And on the second line, it watches the changes to the ref and sync up with page's title.</p>
<p>Emm, maybe it's a little bit hard to catch on what's happened in the first line, let me explain a bit.</p>
<VueUseFn name="useTitle"/>
<h3>Reuse Refs <MarkerCore /></h3>
<p>Here, we utilized an interesting behavior of the ref function.</p>
<p>Similar to <code>unref</code> - <code>ref</code> also checks whether the passed value is ref or not. If you passed a ref to it, it will it as-is - since it's already a ref, there is no need to make another.</p>
<pre><code class="language-ts">const foo = ref(1)   // Ref&lt;1&gt;
const bar = ref(foo) // Ref&lt;1&gt;

foo === bar // true
</code></pre>
<pre><code class="language-ts">function useFoo(foo: Ref&lt;string&gt; | string) {
  // no need!
  const bar = isRef(foo) ? foo : ref(foo)

  // they are the same
  const bar = ref(foo)

  /* ... */
}
</code></pre>
<p>This could also be extremely useful in composable functions that take <code>MaybeRef</code> as argument types.</p>
<h3><code>ref</code> / <code>undef</code></h3>
<p>Let's do a quick summary so far.</p>
<ul>
<li><code>MaybeRef&lt;T&gt;</code> works well with <code>ref</code> and <code>unref</code>.</li>
<li>Use <code>ref()</code> when you want to normalized it as a Ref.</li>
<li>Use <code>unref()</code> when you want to have the value.</li>
</ul>
<pre><code class="language-ts">type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T

function useBala&lt;T&gt;(arg: MaybeRef&lt;T&gt;) {
  const reference = ref(arg) // get the ref
  const value = unref(arg)   // get the value
}
</code></pre>
<p>We can use <code>MaybeRef</code> in arguments to make the function flexible, and use <code>ref()</code> when you want to normalized it as a Ref and use <code>unref()</code> when you want to get the value. Both of them are universal and no conditions needed.</p>
<h3>Object of Refs <MarkerPattern /></h3>
<p>Another pattern today is to use objects of refs. When you need to return multiple data entries in a composable function, consider returns an object composed by refs.</p>
<pre><code class="language-ts">import { ref, reactive } from 'vue'

function useMouse() {
  return { 
    x: ref(0),
    y: ref(0)
  }
}

const { x, y } = useMouse()
const mouse = reactive(useMouse())

mouse.x === x.value // true
</code></pre>
<p>In this way, users can have the full features of ES6 object destructure. The restructure values are refs, so the reactivity still remains, and users can also rename them, or take only partial of what they want.</p>
<p>On this other hand, it's also flexible enough when users want to use it as a single object, simply wrap it with the reactive function, the refs will get unwrapped as a property automatically.</p>
<p>That said, users can get benefits from both <code>ref </code>and <code>reactive</code> as need.</p>
<h3>Async to &quot;Sync&quot; <MarkerTips /></h3>
<p>Since we are constructing &quot;connections&quot; using Composition API, we can actually make async functions to &quot;sync&quot; by building the connections first before it resolves.</p>
<pre><code class="language-ts">const data = await fetch('https://api.github.com/').then(r =&gt; r.json())

// use data
</code></pre>
<p>Let's say we want to request some data use the <code>fetch</code> API. Normally we need to <code>await</code> the request been responded and data been parsed, before we can use the data. With Composition API, we can make the data as a ref of null, then be fulfilled later.</p>
<pre><code class="language-ts">const { data } = useFetch('https://api.github.com/').json()

const user_url = computed(() =&gt; data.value?.user_url)
</code></pre>
<p>This can make your apps take the time to handle other stuff while waiting for the data to be fetched. The idea is similar to react's stale-while-revalidate, but with much easier implementation.</p>
<h3><code>useFetch</code> <Marker class="text-blue-400">Case</Marker></h3>
<p>The implementation can be simplified down to this, all you have to do is to assign the value to <code>ref</code> when the promise got resolved.</p>
<pre><code class="language-ts">export function useFetch&lt;R&gt;(url: MaybeRef&lt;string&gt;) {
  const data = shallowRef&lt;T | undefined&gt;()
  const error = shallowRef&lt;Error | undefined&gt;()

  fetch(unref(url))
    .then(r =&gt; r.json())
    .then(r =&gt; data.value = r)
    .catch(e =&gt; error.value = e)

  return {
    data,
    error
  }
}
</code></pre>
<p>In the real world, we might also need some flags to show the current state of the request, where you can find the full code in VueUse.</p>
<VueUseFn name="useFetch"/>
<h3>Side-effects Self Cleanup <MarkerPattern /></h3>
<p><code>watch</code> and <code>computed</code> functions in Vue will stop themselves automatically along with the components unmounting. We'd recommend following the same pattern for your custom composable functions.</p>
<p>By calling the <code>onUnmounted</code> hooks inside your composable functions, you can schedule the effect clean-up logic.</p>
<pre><code class="language-ts">import { onUnmounted } from 'vue'

export function useEventListener(target: EventTarget, name: string, fn: any) {
  target.addEventListener(name, fn)

  onUnmounted(() =&gt; {
    target.removeEventListener(name, fn) // &lt;--
  })
}
</code></pre>
<p>For example, it's common to use <code>addEventListener</code> to register the handler to DOM events. When you finish the usage, you would also need to remember to unregister it using <code>removeEventListener</code>. In this case, we can have a function <code>useEventListener</code> that unregister itself along with the component so you don't need to worry about it anymore.</p>
<VueUseFn name="useEventListener"/>
<h3><code>effectScope</code> RFC <Marker class="text-purple-400">Upcoming</Marker></h3>
<p>While side-effects auto clean-up is nice, sometimes you might want to have better controls over when to do that. I drafted an RFC proposing a new API called <code>effectScope</code> to collect those effects into a single instance, that you can stop them together at the time you want. This is likely to be implemented and shipped with Vue 3.1. Check out for more details if it get you interested.</p>
<pre><code class="language-ts">// effect, computed, watch, watchEffect created inside the scope will be collected

const scope = effectScope(() =&gt; {
  const doubled = computed(() =&gt; counter.value * 2)

  watch(doubled, () =&gt; console.log(double.value))

  watchEffect(() =&gt; console.log('Count: ', double.value))
})

// dispose all effects in the scope
stop(scope)
</code></pre>
<h3>Typed Provide / Inject</h3>
<p>We have a set of new APIs called <code>provide</code> and <code>inject</code>. It's basically for sharing some context for the component's children to consume and reuse. They are two separate function, which means TypeScript can't actually infer the types for each context automatically.</p>
<p>But here we have a solution for that. Vue provided a type helper called <code>InjectionKey</code> where you can define a symbol that carries the type you want, and then it will hint <code>provide</code> and <code>inject</code> to have proper autocompletion and type checking.</p>
<pre><code class="language-ts">// context.ts
import { InjectionKey } from 'vue'

export interface UserInfo {
  id: number
  name: string
}

export const injectKeyUser: InjectionKey&lt;UserInfo&gt; = Symbol()
</code></pre>
<p>For example, here I defined an interface <code>UserInfo</code> which contains two properties. And I exported a symbol with the <code>InjectionKey</code> type.</p>
<pre><code class="language-ts">// parent.vue
import { provide } from 'vue' 
import { injectKeyUser } from './context'

export default {
  setup() {
    provide(injectKeyUser, {
      id: '7', // type error: should be number
      name: 'Anthony'
    })
  }
}
</code></pre>
<p>In usage, I can use the <code>provide</code> function to provide the data with key. Can you see here I get a type error that the id should be a number. So I can catch up the error right away before it goes to production.</p>
<pre><code class="language-ts">// child.vue
import { inject } from 'vue' 
import { injectKeyUser } from './context'

export default {
  setup() {
    const user = inject(injectKeyUser) 
    // UserInfo | undefined

    if (user)
      console.log(user.name) // Anthony
  }
}
</code></pre>
<p>And in the child component, we can use the <code>inject</code> function with the key as well. You can see it correctly infers the type <code>UserInfo</code> and so as its property.</p>
<h3>Shared State <MarkerPattern /></h3>
<p>With the flexibility of Vue's Composition API, sharing state is actually quite simple.</p>
<pre><code class="language-ts">// shared.ts
import { reactive } from 'vue'

export const state = reactive({
  foo: 1,
  bar: 'Hello'
})
</code></pre>
<p>You can declare some ref or reactive state in a js module, and import them to your components. Since they are using the same instance, the state will be just in sync.</p>
<pre><code class="language-ts">// A.vue
import { state } from './shared.ts'

state.foo += 1
</code></pre>
<pre><code class="language-ts">// B.vue
import { state } from './shared.ts'

console.log(state.foo) // 2
</code></pre>
<p>But please note this is actually not SSR compatible. In SSR your server will create a new app on each request, where this approach will keep the state persistent across multiple rendering. And normally it's not what we would expect.</p>
<h3>Shared State (SSR friendly) <MarkerPattern /></h3>
<p>Let's see if we can make a solution for it to work with SSR.</p>
<pre><code class="language-ts">export const myStateKey: InjectionKey&lt;MyState&gt; = Symbol()

export function createMyState() {
  const state = {
    /* ... */
  }

  return {
    install(app: App) {
      app.provide(myStateKey, state)
    }
  }
}

export function useMyState(): MyState {
  return inject(myStateKey)!
}
</code></pre>
<p>By using <code>provide</code> and <code>inject</code>, to share the state one the App context, which means it will be created every time when the server doing the rendering. You can see here I have two function, <code>createMyState</code> and <code>useMyState</code>. <code>createMyState</code> will returns a Vue plugin that provide the state to the App. While <code>useMyState</code> is just a wrapper of <code>inject</code> using the same key.</p>
<pre><code class="language-ts">// main.ts
const App = createApp(App)

app.use(createMyState())
</code></pre>
<pre><code class="language-ts">// A.vue

// use everywhere in your app
const state = useMyState()
</code></pre>
<p>In usage, we can create the state in the main entry and pass it to <code>app.use</code>. Then you can use the hook <code>useMyState</code> everywhere in your components.</p>
<p>If you have ever tried Vue Router v4, it actually uses a similar method to do that like <code>createRouter</code> and `useRouter.</p>
<h3>useVModel <MarkerTips /></h3>
<p>One last tip I'd like to share is a utility called <code>useVModel</code>.</p>
<pre><code class="language-ts">export function useVModel(props, name) {
  const emit = getCurrentInstance().emit

  return computed({
    get() {
      return props[name]
    },
    set(v) {
      emit(`update:${name}`, v)
    }
  })
}
</code></pre>
<p>It's just a simple wrapper to the component model to bind with <code>props</code> and <code>emit</code>. This is actually a lifesaver to me.</p>
<pre><code class="language-ts">export default defineComponent({
  setup(props) {
    const value = useVModel(props, 'value')

    return { value }
  }
})
</code></pre>
<p>We can take a look at the code, you can see we used a writable computed. When accessing the value, we forward the value of props to it, and when writing, we emit out the update event automatically so you can use just like a normal ref.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;input v-model=&quot;value&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>Even more, we can actually bind into our children elements's <code>v-model</code> very easily.</p>
<VueUseFn name="useVModel"/>
<h2>Vue 2 &amp; 3</h2>
<p>That's all the tips and patterns I have for today.</p>
<p>As you might think those are for Vue 3 only, but actually they also applies for Vue 2!</p>
<h3><code>@vue/composition-api</code> <Marker class="text-teal-400">Lib</Marker></h3>
<p>In case you didn't know that, if you are still on Vue 2 but want to start using the Composition API, here we offered an official plugin that enables the Composition API for your Vue 2 app. Give it a try if you haven't.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vuejs/composition-api">vuejs/composition-api</a></p>
<pre><code class="language-ts">import Vue from 'vue'
import VueCompositionAPI from '@vue/composition-api'

Vue.use(VueCompositionAPI)
</code></pre>
<pre><code class="language-ts">import { ref, reactive } from '@vue/composition-api'
</code></pre>
<h3>Vue 2.7 <Marker class="text-purple-400">Upcoming</Marker></h3>
<p>We also announced <a href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md#for-those-who-absolutely-need-ie11-support">our plan for Vue 2.7</a> recently. Vue 2.7 will be the last minor version of Vue 2 with long time support for existing projects and those who still need IE 11 support. We will back-port Vue 3's new features to Vue 2.7 and migrate the <code>@vue/compositon-api</code> plugin into it. Stay tuned on that.</p>
<ul>
<li>Backport <code>@vue/composition-api</code> into Vue 2's core.</li>
<li><code>&lt;script setup&gt;</code> syntax in Single-File Components.</li>
<li>Migrate codebase to TypeScript.</li>
<li>IE11 support.</li>
<li>LTS.</li>
</ul>
<h3>Vue Demi <Marker class="text-teal-400">Lib</Marker></h3>
<p>If you are a library author want your libraries to support Vue 2 and 3 with the same codebase. You can try Vue Demi, which eases out the difference between Vue 2 and 3 and auto-detects users' environment.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vueuse/vue-demi">vueuse/vue-demi</a></p>
<pre><code class="language-ts">// same syntax for both Vue 2 and 3
import { ref, reactive, defineComponent } from 'vue-demi'
</code></pre>
<h2>Thank you!</h2>
<p>That's all for today.</p>
<p>Due to the time limit, it's a shame that I can not share all I have learned with you. As the Vue composition API is still fairly new, I believe there are more patterns and better practices for us to found.</p>
<p>To find more information, do check out the <a href="https://github.com/vueuse">VueUse org on GitHub</a> and <a href="https://vueuse.org/add-ons.html">its awesome ecosystem</a>, and follow us on Twitter <a href="https://twitter.com/vueuse">@vueuse</a> to keep up-to-date with news and tips.</p>
<p>Thank you!</p>
<p align="center">
  <a href="https://github.com/sponsors/antfu#sponsors">
    <img src='https://cdn.jsdelivr.net/gh/antfu/static/sponsors.svg'>
  </a>
</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Develop with Vite - Vue Beijing]]></title>
            <link>https://antfu.me/posts/vue-beijing-2021</link>
            <guid>https://antfu.me/posts/vue-beijing-2021</guid>
            <pubDate>Sun, 28 Mar 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>This is the transcript of my talk at <a href="https://twitter.com/beijing_vue">Vue Beijing</a></p>
<p>Slides: <a href="https://antfu.me/talks/2021-03-28/en">English ver.</a> | <a href="https://antfu.me/talks/2021-03-28/zh">中文 ver.</a></p>
<p>Recording: <a href="https://www.youtube.com/watch?v=xx8gEHet6n8">YouTube (English)</a></p>
</blockquote>
<p>I guess many of you have already heard about <a href="https://github.com/vitejs/vite">Vite</a>, as the next thing replacing other bundlers like Webpack. Well, it's actually not 100% true. While we are used to &quot;Build with Webpack&quot;, and now, more precisely, we are <strong>Developing with Vite</strong>.</p>
<p>Today I am going to present you with a brief introduction to Vite, the next-generation development tools. And I believe you will find out the answer after it.</p>
<h2>What is Vite?</h2>
<p>Vite is a French word meaning fast. The initial motivation of it is that Evan You, the creator of Vue, got an idea of making a dev server with hot reload for Vue Single File Component without a bundler. And yeah, after a few days, Vite comes out.</p>
<p>With the name of fast, it has to be fast. And it is.</p>
<p>Let me show you a quick <a href="https://twitter.com/amasad/status/1355379680275128321">demonstration of how fast it is</a>. On the left-hand side, we have Create React App, and on the right we have Vite. And you can see during I am introducing to them, the Vite app is already ready and playable, while the other one just finishes installing its dependencies. In this demo, we can see we have over 4x faster boot-up speed improvement over Create React App, on the single component starter template. And actually, it's not even showing the full potential of Vite.</p>
<p>So how could Vite be so fast?</p>
<p>First, Vite is opinionated on providing better DX. It assumes that you are using modern browsers for development, so we don't need to have complex transpiling and polyfills involved. Also since your browser already understands Native ES module, we can even skip the bundling process and let the browser do it for us. We also involved with some optimizations to make it even faster, which I will go through them later.</p>
<p>We have a build mode for production powered by rollup. The difference between development and production make Vite capable of having good experiences for both of them.</p>
<h3>The Dev Server</h3>
<p>In a traditional bundle-based dev server, when we start the server, it will bundle your entire app and the server is ready only until the bundling is finished. In a large-scale app, it could take quite a lot of time.</p>
<p>Native ESM bases server, on the other hand, does need to do the bundling at all. The server is ready immediately and it will only transpile the modules of the pages you have opened on-demanded. So even you have a huge app with thousands of pages, it will be constantly fast as it only needs to transpile the modules for one page.</p>
<p>The transpling is powered by <a href="https://github.com/evanw/esbuild">esbuild</a>. It is a transpiler and bundler written in Go and build to native code. It is optimized with speed in mind and utilizes the potential of parallelism. It claims that it can be 10-100x faster than the traditional build tools.</p>
<p>With the support <a href="https://github.com/evanw/esbuild">esbuild</a>, we are able to support JSX, TypeScript out-of-the-box.</p>
<h3>Dependencies Pre-bundling</h3>
<p>Another optimization of Vite is the dependencies pre-bundling. Normally, your dependencies do not change really often unless you are upgrading them, but on the other hand, your user code can change everyday.</p>
<p>So by treating the user code and dependencies differently, we pre bundles your dependencies into a single file standard ESM that can be understood by the browser. In this way, we ease out the difference of packages shipping different js formats like <code>cjs</code> or node favored modules. It also reduced HTTP request overhead and importing waterfall.</p>
<p>And this bundling process is also powered by <a href="https://github.com/evanw/esbuild">esbuild</a>, with over 20x faster performance.</p>
<h3>Hot Module Replacement</h3>
<p>Another important part of Vite is that it has out-of-box hot module replacement support. Whenever you made a change to your code, the HMR is triggered. It's smart enough to know which modules would be affected by the changes and replace them efficiently. And we have first-party support for Vue single-file components and React Refresh.</p>
<p>As Vite is made by Evan, you may think it's only Vue. Well, initially, it was kind of true, but things are different now.</p>
<p>From Vite 2.0, it's now framework-agnostic and Vue is supported through a plugin. It also comes with a bunch of new features and improvements, for example the universal plugin system and first-class SSR. For more details, you check out the links in the slide.</p>
<p>You can use <code>npm init</code> to create the starter project with the official templates. As you can see, we have supported Vue, React, Preact, Lit Element, Svelte, and even vanilla. It's not limited to these, we will keep adding more as we go.</p>
<hr>
<h2>Powerful Plugins System</h2>
<p>Vite's plugins are compatible with Rollup plugins. This means you can use the huge amount of existing plugins from rollup on Vite.</p>
<p>You can check out <a href="https://github.com/patak-js/vite-rollup-plugins">this Vite Rollup Plugins site</a> by our team member <a href="https://github.com/patak-js">@patak-js</a>. It lists all the compatibility of popular rollup plugins with some demo and guides of how to use them.</p>
<p>We also have <a href="https://github.com/vitejs/awesome-vite">an awesome list</a> that lists Vite plugins for different ecosystems. Check it out, I believe you will find some of them useful to you.</p>
<hr>
<h2>Fresh Vue Authoring Experience</h2>
<p>I'd like to feature some Vite plugins for Vue that provide the Fresh authoring experience on creating Vue apps.</p>
<h3><a href="https://github.com/hannoeru/vite-plugin-pages"><code>vite-plugin-pages</code></a> by <a href="https://github.com/hannoeru">@hannoeru</a></h3>
<p>It provides Nuxt.js-like file base routing, with dynamic routes support that can be accessed as the props in the page component.</p>
<p>Only with 3 lines of code, you can set up this feature and use it immediately.</p>
<pre><code class="language-ts">import { createRouter } from 'vue-router'
import routes from 'virtual:generated-pages'

const router = createRouter({ routes })
</code></pre>
<p>Check <a href="https://github.com/hannoeru/vite-plugin-pages">its docs</a> for more.</p>
<h3><a href="https://github.com/hannoeru/vite-plugin-components"><code>vite-plugin-components</code></a> by <a href="https://github.com/antfu">@antfu</a></h3>
<p>In Vue, writing the name of the component four times in order to import them is kind of a pain for me. So I made this plugin to do the component auto-importing. Now you can put your components under <code>src/components</code> and then use them everywhere without needing to import them. We also have built-in support for auto importing component libraries with minimal configurations. For now, we have supported Vuetify, Ant Design Vue, Element Plus, Vant, and so on.</p>
<p>From:</p>
<pre><code class="language-html">&lt;script&gt;
import HelloWorld from './src/components/HelloWorld.vue'

export default {
  components: {
    HelloWorld
  }
}
&lt;/script&gt;

&lt;template&gt;
  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>To:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h3><a href="https://github.com/hannoeru/vite-plugin-icons"><code>vite-plugin-icons</code></a> by <a href="https://github.com/antfu">@antfu</a></h3>
<p>Another one is <code>vite-plugin-icons</code>. It allows you to use icons from any icon set, for example, Material design icons and Font awesome. Which the on-demand spirit of Vite, this will only ship with the icons that you actually use. So you can say goodbye to the old-school icon font approach that downloads a huge font with all the icons that you don't actually need.</p>
<p>It also works well with the component auto importing, and you can use them like magic.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;i-carbon-accessibility/&gt;
  &lt;i-mdi-account-box style=&quot;font-size: 2em; color: red&quot;/&gt;
&lt;/template&gt;
</code></pre>
<h3><a href="https://github.com/windicss/vite-plugin-windicss"><code>vite-plugin-windicss</code></a> by <a href="https://github.com/antfu">@antfu</a></h3>
<p>If you have ever used <a href="https://tailwindcss.com/">Tailwind CSS</a>, you must aware it's actually quite slow in the dev server as it ships all the utilities with megabytes of CSS to your client. This becomes the slowest part of my Vite app.</p>
<p>Luckily, we have a new thing called <a href="https://github.com/windicss/windicss">Windi CSS</a>, which you can think of it as the on-demand Tailwind CSS. Instead of shipping all the combinations of classes and purge them down later. It only generates the classes you actually use. Turns out it can be 20-100x faster than the traditional Tailwind. While it's on-demand, it also opens up more features like unit auto-inferring. Do check it out if you are using Tailwind.</p>
<h3>Try them all</h3>
<p>If you found them interesting and want to try it yourself, I also made a starter template call <a href="https://github.com/antfu/vitesse">Vitesse</a>, with all of them included and more features. Pull it down and check out.</p>
<p>These are only a small part of our plugins ecosystem, we have more of them available in the <a href="https://github.com/vitejs/awesome-vite">awesome list</a> do remember to check them out.</p>
<h3>Vue 2 for Vite</h3>
<p>If you are still using Vue 2, no worries, we have your covered!</p>
<p>While the official Vue plugin is for Vue 3. Another Vite team member <a href="http://github.com/underfin">@underfin</a> made the plugin <a href="https://github.com/underfin/vite-plugin-vue2"><code>vite-plugin-vue2</code></a> for Vue 2. With a single line in the config, you are good to go. It's been wildly adapted already, for example, <a href="https://github.com/nuxt/vite">Nuxt 2 for Vite</a> is powered on it.</p>
<p>In the <a href="https://github.com/vitejs/awesome-vite">awesome list</a>, we have marked the compatibility for each plugin of the Vue 2 support. Many of them are isomorphic to both Vue 3 and 2. If you are going to try Vue 2, you don't want to miss it.</p>
<h3>Legacy Browser Support</h3>
<p>Vite uses native ESM on both development and production, but if you want to enable legacy browsers that do not support ESM, no problem, we have it.</p>
<p>There is an official plugin <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy"><code>@vitejs/plugin-legacy</code></a> that uses Babel and System JS to transform the modules for legacy support.</p>
<pre><code class="language-ts">// vite.config.js
import legacy from '@vitejs/plugin-legacy'

export default {
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11']
    })
  ]
}
</code></pre>
<p>Check out the docs for more details.</p>
<hr>
<h2>Ecosystem and Community</h2>
<p>Then, let's talk a bit about the community.</p>
<p>I bet you already have this question - Vite is great, but what does Vite mean for the existing Vue ecosystem? Let me help you to find it out.</p>
<p>How about <a href="https://github.com/vuepress/vuepress-next">VuePress</a>? It's actually <a href="https://twitter.com/meteorlxy_cn/status/1370728812971917315">already supported Vite in the version 2 beta</a>! In v2, you can swap the engine between Webpack and Vite, and have the instant reload from Vite. Check out the docs for how it works!</p>
<p>As for Nuxt, we actually have some exciting news! The <a href="https://twitter.com/_pi0_/status/1352344462954016768">upcoming Nuxt 3 will support interchangeable engines between Webpack and Vite</a>. And you can get the benefit of the huge Nuxt community. It will be available as a public beta at Q2 this year. They also release <a href="https://twitter.com/_pi0_/status/1365049110982778884">an experimental project for Nuxt 2 to support Vite</a> where you can try it today.</p>
<p>About Vue CLI, as <a href="https://twitter.com/youyuxi/status/1354584410482499585">Evan mentioned</a>, we weren't intended to replace Vue CLI with Vite, but it turns out it could be. The long-term goal of Vue CLI is to support Vite with a powerful scaffolding capability and easier to get started.</p>
<p>We also have a community plugin <a href="https://github.com/IndexXuan/vue-cli-plugin-vite"><code>vue-cli-plugin-vite</code></a> that enables Vite support in Vue CLI that you can play with it today.</p>
<hr>
<h2>Higher-level Integrations</h2>
<p>We also have a community plugin that enables Vite support in Vue CLI that you can try today. And on top of Vite, we are now having some cool higher-level integrations tools.</p>
<p>The first one is <a href="https://github.com/vuejs/vitepress">VitePress</a>, a Vite and Vue powered static site generator. Similar to VuePress, but with more opinionated pre-configuration. This project is still experimental but already served as the generator for many official documentation sites, including the Vite docs itself.</p>
<p><a href="https://github.com/ream/ream">Ream</a> is a Vite-based framework with the support of fast SSR built-in by <a href="https://github.com/egoist">@egoist</a>. At the time I am preparing these slides, it's doing a rewrite to make not only for Vue but also for any frameworks. Stay tuned on that.</p>
<p>Edge side rendering becomes quite popular recently, and we are also having a tool called <a href="https://github.com/frandiox/vitedge">Vitedge</a> by <a href="https://github.com/frandiox">@frandiox</a> to bring it to Vite. Take a look at its repo as well.</p>
<p>Vite also supports <a href="https://vitejs.dev/guide/backend-integration.html">backend integrations</a>, now we already have <a href="https://github.com/ElMassimo/vite_ruby">Vite Ruby</a> by <a href="https://github.com/ElMassimo">@ElMassimo</a> and <a href="https://github.com/innocenzi/laravel-vite">Laravel Vite</a>by <a href="https://github.com/innocenzi">@innocenzi</a> in the community. They leverage Vite to serve the front-end and benefit from Vite's fast performance.</p>
<p>You can also set up your own backend integrations easily by following the docs below.</p>
<hr>
<h2>Upcoming</h2>
<p>Not only for Vue and the new tools. The tools you love are also going to support Vite. Here are some news for upcoming things I'd like to share with you.</p>
<p><a href="https://github.com/sveltejs/kit">Svelte Kit</a> is the next official build tools for Svelte, and <a href="https://github.com/sveltejs/kit/pull/409">they are moving from Snowpack to Vite</a>. It's in the early beta now and you can check it out if it got you interested.</p>
<p><a href="https://twitter.com/_jessicasachs/status/1354585366620221443">Cypress is also adding the first-class Vite support</a>. I believe we can see it ready within this year.</p>
<p>And <a href="https://twitter.com/storybookjs/status/1371894052015239170">Storybook is also exploring the interchangeable engines for Vite and Snowpack</a>. You can also keep an eye on that.</p>
<hr>
<h2>Start Vite today!</h2>
<p>We are waiting for you to join our community and start playing with us!</p>
<p>Just firing up this command in your terminal to get the first impressions!</p>
<pre><code class="language-bash">npm init @vitejs/app
</code></pre>
<p>That's all for today. Join the <a href="http://chat.vitejs.dev/">discord</a> to chat with us and follow us on <a href="https://twitter.com/vite_js">Twitter</a> to get the latest news.</p>
<p>See you in the community, thank you!</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Reflection of Speaking in Public]]></title>
            <link>https://antfu.me/posts/reflection-of-speaking-in-public</link>
            <guid>https://antfu.me/posts/reflection-of-speaking-in-public</guid>
            <pubDate>Sat, 27 Mar 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[My sincere apologies to everyone involved.]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>Disclaimer: All the words are only representing my opinions. None of them applies to the Windi CSS's author nor the team.</p>
</blockquote>
<p>The past two weeks have been tough for me. I have caused some drama where it might not need to be like that. The guilty keeps spinning around my head, asking myself if I made the right decisions, or what can be better if I am not taking it this way.</p>
<p>I guess I am still immature and naive to the community. I was so lucky to get so many of you enjoying my work, subscribing to my feeds, more than I could ever imagine. I was not aware of how the expression of myself could have so much effect on others.</p>
<p>I couldn't help myself not to think about what's the best outcome we could possibly have, if both of us could make better decisions. Maybe we can have a world that Windi and Tailwind JIT could co-exist, helping and inspiring each other, like react and preact. Windi could be the community-driven playground/experiment field to try out new ideas and ships rapidly, and Tailwind could take those good enhancements that have been proven in Windi and make it more solid and ready for production. That might be the things we should see them happen in the open-source rather than the current drama and sadness.</p>
<p>Not saying I think what Tailwind does is acceptable to me. I believe there isn't something called &quot;original ideas&quot; - we are all learning and inspiring from others. Giving proper credit to where the inspirations come from is the least thing we can do to make open source a better place and encourage more people to share their ideas/code in the public space.</p>
<p>But after these days of reflection, I think I could be more mature and calm to handle this better and prevent all of these from happening. Here are some thoughts for myself to be aware of not doing the same thing again.</p>
<ul>
<li>I should have more active communication with Adam and Tailwind on this thing before I spoke it out in public. Or even better before they make the announcement.</li>
<li>I should not take this personally and emotionally, and not assail Adam and the Tailwind team.</li>
<li>When Tailwind appended the mention in the comments, I should call it over and move on. Instead of bringing this up once again.</li>
<li>I should ask for the opinions from the Windi team before going public.</li>
</ul>
<p>I had failed to make none of these, resulting in the worst outcome. I was irresponsible to do this for both the community and the Windi team who have trusted me.</p>
<p><strong>My sincere apologies to Adam, the Tailwind team, the Windi team, and everybody involved with this drama.</strong></p>
<p>I don't know what this will end with, but fighting is definitely not something I meant to see. This drama was started by me, and I wish we can call it an end. I don't really want to see such things happening again, but I truly wish I can handle it better next time taking the lesson I have learned today. After all, I still believe people here in open source are with good willing to make things better for everyone.</p>
<p>Thank you for reading through. And hope you could understand and forgive this naive and immature boy.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Windi CSS and Tailwind JIT]]></title>
            <link>https://antfu.me/posts/windicss-and-tailwind-jit</link>
            <guid>https://antfu.me/posts/windicss-and-tailwind-jit</guid>
            <pubDate>Thu, 18 Mar 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[Wish this is the end.]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>Disclaimer: All the words are only representing my opinions. None of them applies to the Windi CSS's author nor the team.</p>
</blockquote>
<Tweet>
<p lang="en" dir="ltr">Congrats Tailwind, and thanks for NOT mentioning Windi CSS at all for your new ideas.<br><br>I appreciated how did Tailwind power my apps and make my life easier. But this really changed my mind about how I see the people behind it.<br><br>Check out <a href="https://t.co/kcEzm5Ickp">https://t.co/kcEzm5Ickp</a> by <a href="https://twitter.com/satireven?ref_src=twsrc%5Etfw">@satireven</a>. <a href="https://t.co/tkJCy8Pgb3">https://t.co/tkJCy8Pgb3</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371533878800748545?ref_src=twsrc%5Etfw">March 15, 2021</a>
</Tweet> 
<p>I spoke out for <a href="https://github.com/windicss/windicss">Windi CSS</a> just because keeping silence on this also means we are encouraging such things to happen again in the open-source community.</p>
<p>Tailwind was once my favorite CSS framework and I was really happy to see we made it works on Vite <a href="https://twitter.com/antfu7/status/1361398324587163648">much faster</a> with <a href="https://github.com/voorjaar">@voorjaar</a>'s astonishing Windi CSS compiler. But I was totally unexpected to see that end up being like this. Don't get me wrong, it's great to see Tailwind's long pain get solved officially with Tailwind JIT and benefit the community. What I am saying is that Tailwind used/inspired by Windi's idea <strong>without even mentioning Windi CSS once and claiming it's their own ideas</strong> (until 20min after my tweets about that, <a href="https://twitter.com/adamwathan/status/1371542711086559237?s=20">they appended two tweets in the comments</a>, mentioned about Windi but still implies it's their idea. That's all we got). No official reply of this whole thing, not updates to their repo's README, at all.</p>
<p>I don't want to speculate what's the reasons or motivations behind it, all I know is that <strong>I will not use any products from Tailwind Labs anymore</strong>. If you think I was reacting too much or it was not a big deal, then I truly wish such things would never happend on you once again.</p>
<Tweet>
<p lang="en" dir="ltr">I remember the day when Windi got blown up on Twitter, <a href="https://twitter.com/adamwathan?ref_src=twsrc%5Etfw">@adamwathan</a> called me and asked me about how Windi CSS works and he is happy to make it official. And yeah, I was excited to see things are improving for the whole community, so I shared all I know with him.<br><br>1/n <a href="https://t.co/Ho1DddqA33">https://t.co/Ho1DddqA33</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371538602488786945?ref_src=twsrc%5Etfw">March 15, 2021</a>
</Tweet>
<Tweet>
<p lang="en" dir="ltr">It&#39;s almost impossible for a small org like us to fight with the giant Tailwind. But we will not give up just because of this.<br><br>Let&#39;s see and good luck.</p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371538609388494852?ref_src=twsrc%5Etfw">March 15, 2021</a>
</Tweet>
<p>On the bright side, Windi pushed Tailwind to make the JIT and improved the DX and Tailwind forced Windi to be independent and evolving to not being a &quot;Tailwind accessory&quot; any longer.</p>
<p>There is another community based CSS-in-JS alternative called <a href="https://github.com/tw-in-js/twind">Twind</a>, which you definitely want to check out (they are working closely with Windi to bring an uniformed community standard/spec of our DSL, cheers <a href="https://github.com/sastan">@sastan</a>!).</p>
<p>As for myself, I will spend more time on working with Windi CSS to make it even better. Here is some of exciting things we are working on:</p>
<Tweet>
<p lang="en" dir="ltr">Spoiler of the new piece of our playground - interactive selector.<br><br>I always find myself trouble picking the directions of rounded corners and looking up for a huge table of all the possible combinations could be inefficient. So yeah :)<br><br>rounded-1/2 is new in Windi CSS btw 😉 <a href="https://t.co/f841k9BgPF">https://t.co/f841k9BgPF</a> <a href="https://t.co/pVIlB2X1nY">pic.twitter.com/pVIlB2X1nY</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371779599084888064?ref_src=twsrc%5Etfw">March 16, 2021</a>
</Tweet>
<Tweet>
<p lang="en" dir="ltr">Limitation? Let&#39;s break it!💥<br><br>Upcoming feature in <a href="https://twitter.com/windi_css?ref_src=twsrc%5Etfw">@windi_css</a> 🍃<br>&quot;Design in DevTools&quot;!<br><br>Whenever you made changes to the classes in DevTools, the CSS updates automatically for you, on-demand as always :)<br><br>Idea credit goes to <a href="https://twitter.com/MaximoMussini?ref_src=twsrc%5Etfw">@maximomussini</a> 🙌 <a href="https://t.co/DHf2h5wroM">pic.twitter.com/DHf2h5wroM</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1372244287975387145?ref_src=twsrc%5Etfw">March 17, 2021</a>
</Tweet>
<p>Thanks for reading though. Don't feel any pressure about using any tools that you needed. I choose not to use them just because my personal preference. I don't want to force anyone to switch their stack because reading this post, we will keep improve it and show you which is the better one you should use :)</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Rewrite in Vite]]></title>
            <link>https://antfu.me/posts/rewrite-in-vite</link>
            <guid>https://antfu.me/posts/rewrite-in-vite</guid>
            <pubDate>Sun, 31 Jan 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[My site is now powered by Vite!]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p>The page you are looking at is now powered by <a href="https://github.com/vitejs/vite">Vite</a>. This is something I want to do for a long while since Vite came out, and it's finally done. As I have mentioned in my <a href="/posts/new-house">first blog post</a>, it was powered <a href="https://gridsome.org/">Gridsome</a> using Vue 2. With this overhaul, I can now take full advantage of Vue 3 and the <a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a> with the new <a href="https://github.com/vuejs/rfcs/pull/227"><code>&lt;script setup&gt;</code> SFC style</a>.</p>
<p>The reason for it taking me so long to do this is because I am busy (enjoy) doing <a href="https://americanexpress.io/yak-shaving">yak shaving</a>, for the tools I need to build this site.</p>
<h3>Fundamentals</h3>
<p>It begins with me trying to improve the DX using icons in <a href="/posts/journey-with-icons">this post</a>. At that time, Vue 3 just into RC, and Vite didn't reach 1.0 yet. Hearing a lot of how good Vue 3 and Vite are, I decided to give them a try on building the icon site I want to build for a long time. Since Vite is such a brand new thing, there aren't many tools/plugins out there, the ecosystem was way far from what Webpack has. I took that as a chance for me to dive deep into how Vite works while doing some contributions the ecosystem. Here is a few tools I made while building the app <a href="https://github.com/antfu/icones">Icônes</a>:</p>
<ul>
<li><a href="https://github.com/antfu/vite-plugin-components">vite-plugin-components</a> - On-demand components auto importing for Vite.</li>
<li><a href="https://github.com/antfu/vite-plugin-pwa">vite-plugin-pwa</a> - Zero-config PWA for Vite.</li>
<li><a href="https://github.com/antfu/purge-icons">vite-plugin-purge-icons</a> - Bundles icons on demand, with a Vite plugin.</li>
</ul>
<p>Also found some awesome tools form the community:</p>
<ul>
<li><a href="https://github.com/iconify/iconify">Iconify</a> - Universal icon framework, by <a href="https://github.com/cyberalien">@cyberalien</a>.</li>
<li><a href="https://github.com/brattonross/vite-plugin-voie">vite-plugin-voie</a> - File system based routing for Vite, by <a href="https://github.com/brattonross">@brattonross</a>.</li>
<li><a href="https://github.com/hannoeru/vite-plugin-pages">vite-plugin-pages</a> - Another file system based route generator, by <a href="https://github.com/hannoeru">@hannoeru</a>.</li>
</ul>
<p>With them, I got the fundamentals of a Vite project setup. Nuxt-liked file-based routing and component auto importing. I was quite satisfied with it as I could focus more on the content and logic rather than getting distracted by the routes setup and component registration.</p>
<p>I also learned <a href="https://tailwindcss.com/">Tailwind CSS</a> as a replacement of the missing UI component libraries for Vue 3. It turns out that I really enjoy Tailwind's way of rapid prototyping. As I got more control over styling things, it makes me think more about the design rather than just applying the default theme of the components library I use.</p>
<h3>Dark Mode</h3>
<p>Dark mode is supported as an experimental feature in Tailwind CSS v1.8 and shipped in v2.0. It supports two modes for you to choose from - <code>media</code> and <code>class</code>. <code>media</code> is something that works out-of-box, it changes based on users' system preference. But the limitation is that you can't toggle it manually as you want. So I went with <code>class</code> mode where I have more controls over it. But that also means I would need to implement the toggling logic myself.</p>
<p>With the power of Vue's Composition API, I am able to combine the best parts of them - reactive to the system's preference while being able to override manually.</p>
<pre><code class="language-ts">import { useStorage, usePreferredDark } from '@vueuse/core'

const preferredDark = usePreferredDark()
const colorSchema = useStorage('color-schema', 'auto')

export const isDark = computed({
  get() {
    return colorSchema.value === 'auto'
      ? preferredDark.value
      : colorSchema.value === 'dark'
  },
  set(v: boolean) {
    if (v === preferredDark.value)
      colorSchema.value = 'auto'
    else
      colorSchema.value = v ? 'dark' : 'light'
  },
})

watch(
  isDark,
  v =&gt; document.documentElement.classList.toggle('dark', v),
  { immediate: true },
)
</code></pre>
<p>Click it to try 👇🏼</p>
<ToggleTheme class="text-2xl pb-2 pt-1"/>
<p>If you would like to use it in your own apps, I also extract the logic above into <a href="https://vueuse.js.org/core/usedark/"><code>useDark()</code> in VueUse</a>. Where you can simply use like this:</p>
<pre><code class="language-ts">import { useDark, useToggle } from '@vueuse/core'

const isDark = useDark()
const toggleDark = useToggle(isDark)
</code></pre>
<h3>Markdown</h3>
<p>After building Icônes, I started working on the <a href="http://codecember.ink/">Codecember</a> project with <a href="https://blog.matsu.io/about">@octref</a>, an initiative of learning and creating generative arts in December. With the spirit of dogfooding, we chosen Vite for building the site. In Codecember we will need to have a prompt every day with some texts, code snippets, and demos. This comes with the problem that Vite does not have a plugin for handling markdown files at that moment, so of course, I made one myself.</p>
<ul>
<li><a href="https://github.com/antfu/vite-plugin-md">vite-plugin-md</a> - Markdown for Vite.</li>
</ul>
<p>Basically, it uses <a href="https://markdown-it.github.io/"><code>markdown-it</code></a> to transform markdown into HTML and feed it into Vue's template compiler. As the generated template is handled by Vue, we can easily support Vue components inside Markdown.</p>
<h3>Syntax Highlighting</h3>
<p>Getting syntax highlight works in dark mode isn't an easy task as well. <a href="https://github.com/shikijs/shiki">Shiki</a> inlined all the colors into the HTML so you would not be bored by the CSS namespace pollution, but that also means it will be really hard to get the colors aware of your global color scheme. <a href="https://prismjs.com/">Prism</a> on the other hand, uses the classes combining the CSS theme to do the job. It's easier to merge two color schemes and make them aware of the <code>dark</code> trigger. The bad thing is, themes are often wrote by different authors with different styles of coloring and styling things. Sometimes, even the font and spacing could be different across different themes. If you ever ran into a similar situation, you should know what I mean. If you don't (lucky you!), see <a href="https://github.com/PrismJS/prism-themes/tree/master/themes">Prism's themes collection</a>(<a href="https://github.com/PrismJS/prism-themes/blob/c24ddffde2737293d9b2df7dc59939d527648863/themes/prism-vs.css#L9"><code>prism-vs.css</code></a> and <a href="https://github.com/PrismJS/prism-themes/blob/c24ddffde2737293d9b2df7dc59939d527648863/themes/prism-vsc-dark-plus.css#L6"><code>prism-vsc-dark-plus.css</code></a> for example).</p>
<p>Fight with them for a while you might be able to ease the misalignment eventually. But what if we can have a smarter way to do this?</p>
<ul>
<li><a href="https://github.com/antfu/prism-theme-vars">prism-theme-vars</a> - A customizable Prism.js theme using CSS variables.</li>
</ul>
<p>Instead of dealing with the lengthy CSS theme, now you can have one in less than 20 lines of CSS variables. For example:</p>
<pre><code class="language-css">@import &quot;prism-theme-vars/base.css&quot;;

:root {
  --prism-foreground: #393a34;
  --prism-background: #fbfbfb;
  --prism-comment: #b8c4b8;
  --prism-string: #c67b5d;
  --prism-literal: #3a9c9b;
  --prism-keyword: #248459;
  --prism-function: #849145;
  --prism-deleted: #a14f55;
  --prism-class: #2b91af;
  --prism-builtin: #a52727;
  --prism-property: #ad502b;
  --prism-namespace: #c96880;
  --prism-punctuation: #8e8f8b;
}
</code></pre>
<p>To have it supports dark mode is extremely simple as well:</p>
<pre><code class="language-css">html:not(.dark) {
  --prism-foreground: #393a34;
  --prism-background: #f8f8f8;
  --prism-comment: #758575;
  --prism-namespace: #444444;
  --prism-string: #bc8671;
  --prism-punctuation: #80817d;
  --prism-literal: #36acaa;
  --prism-keyword: #248459;
  --prism-function: #849145;
  --prism-deleted: #9a050f;
  --prism-class: #2b91af;
  --prism-builtin: #800000;
}

html.dark {
  --prism-foreground: #d4d4d4;
  --prism-background: #1e1e1e;
  --prism-namespace: #aaaaaa;
  --prism-comment: #758575;
  --prism-namespace: #444444;
  --prism-string: #ce9178;
  --prism-punctuation: #d4d4d4;
  --prism-literal: #36acaa;
  --prism-keyword: #38a776;
  --prism-function: #dcdcaa;
  --prism-deleted: #9a050f;
  --prism-class: #4ec9b0;
  --prism-builtin: #d16969;
}
</code></pre>
<p>That's all. You can also play with the themes in the <a href="https://prism-theme-vars.netlify.app/">Playground</a> and make some your own within 5 mins. I created my first code theme in my life using it, which is also exactly what you are looking at :)</p>
<h3>Serve-Side Generatation (SSG)</h3>
<p>While Codecember is more like a site than an app, we would need to do some server-side generation to improve our <a href="https://searchengineland.com/guide/what-is-seo">SEO</a>. Read quite a lot of code from <a href="https://github.com/vuejs/vitepress">VitePress</a>, I came up with this plugin:</p>
<ul>
<li><a href="https://github.com/antfu/vite-ssg">vite-ssg</a> - Server-side generation for Vite.</li>
</ul>
<p>The idea here is fairly simple: bundle the app entry, then for each route, dump the app using APIs from the <a href="https://github.com/vuejs/vue-next/tree/master/packages/server-renderer"><code>@vue/server-renderer</code></a> package. Simplified code here:</p>
<pre><code class="language-ts">import { renderToString } from '@vue/server-renderer'

const createApp = required('dist-ssr/app.js')

await Promise.all(
  routes.map(async(route) =&gt; {
    const { app, router, head } = createApp(false)

    router.push(route)
    await router.isReady()

    const appHTML = await renderToString(app)
    const renderedHTML = renderHTML(indexHTML, appHTML)

    await fs.writeFile(`${route}.html`, renderedHTML, 'utf-8')
  })
)
</code></pre>
<p>The full code can be found <a href="https://github.com/antfu/vite-ssg/blob/fa256449923e05e55bf15dcf4747d517bc22e33a/src/node/build.ts#L94-L104">here</a>.</p>
<p>With the <a href="https://github.com/vueuse/head">@vueuse/head</a> package made by <a href="https://github.com/egoist">@egoist</a>, I made the document head/meta manipulation in SSG with ease. Combining with <a href="https://github.com/antfu/vite-plugin-md">vite-plugin-md</a>, you can even use the frontmatter to set the meta (title, description, og:image, etc.).</p>
<pre><code class="language-html">&lt;script setup&gt;
import { useHead } from '@vueuse/head'

useHead({
  title: 'Website Title',
  meta: [
    {
      name: 'description',
      content: 'Website description',
    },
  ],
})
&lt;/script&gt;
</code></pre>
<h3>The Vite Template</h3>
<p>I found myself making small web apps frequently. Setting up plugins and configs for Vite kinda becomes the bottleneck for me to make my idea landded. So combining with those tools I am using, I made an opinionated template for myself but unexpectedly got quite some good feedback:</p>
<ul>
<li><a href="https://github.com/antfu/vitesse">Vitesse</a> - Opinionated Vite Starter Template</li>
</ul>
<h2>This Website</h2>
<p>This site is <strong>made from <a href="https://github.com/antfu/vitesse">Vitesse</a> combining with all the tools I mentioned above</strong>. To be honest, even making a static site generator right is something hard to me, not to mention that most of the hard parts are already handled by Vite. I am really happy to see so many things I have learned and crafted along the way. And glad I can make these contributions to the Vite ecosystem, that someone could find my work useful for building their apps.</p>
<h2>Thanks</h2>
<p>I can't make all these happened without the help/support from the great community, thank y'all!</p>
<p>Also want to have some special thanks to people made significant contributions towards these projects 🙌 (A-Z)</p>
<ul>
<li><a href="https://github.com/hannoeru">@hannoeru</a></li>
<li><a href="https://github.com/matias-capeletto">@matias-capeletto</a></li>
<li><a href="https://github.com/privatenumber">@privatenumber</a></li>
<li><a href="https://github.com/sibbng">@sibbng</a></li>
</ul>
<p>Appreciation to my sponsors as well for supporting my works:</p>
<p align="center">
  <a href="https://cdn.jsdelivr.net/gh/antfu/static/sponsors.svg">
    <img src='https://cdn.jsdelivr.net/gh/antfu/static/sponsors.svg'>
  </a>
</p>
<p>And thank you for reading through!</p>
<p><strong>This site is now open sourced at <a href="https://github.com/antfu/antfu.me">antfu/antfu.me</a></strong></p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Destructuring... with object or array?]]></title>
            <link>https://antfu.me/posts/destructuring-with-object-or-array</link>
            <guid>https://antfu.me/posts/destructuring-with-object-or-array</guid>
            <pubDate>Wed, 21 Oct 2020 16:00:00 GMT</pubDate>
            <description><![CDATA[Prefer object destructure or array? Can we support both?]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring</a> is a JavaScript language feature introduced in ES6 which I would assume you already familiar with it before moving on.</p>
</blockquote>
<p>We see it quite useful in many scenarios, for example, value swapping, named arguments, objects shallow merging, array slicing, etc. Today I would like to share some of my immature thoughts on &quot;destructuring&quot; in some web frameworks.</p>
<p>I am a Vue enthusiast for sure and I wrote a lot of my apps using it. And I did write React a while for my previous company <s>reluctantly</s>. As the Vue 3.0 came out recently, its exciting Composition API provides quite similar abilities for abstracting. Inspired by <a href="https://github.com/streamich/react-use">react-use</a>, I wrote a composable utility collection library early this year called <a href="https://github.com/antfu/vueuse">VueUse</a>.</p>
<p>Similar to React hooks, Vue's composable functions will take some arguments and returns some data and functions. JavaScript is just like other C-liked programming languages - only one return value is allowed. So a workaround for returning multiple values, we would commonly wrap them with an array or an object, and then destructure the returned arrays/objects. As you can already see, we are having two different philosophies here, using arrays or objects.</p>
<h2>Destructuring Arrays / Tuples</h2>
<p>In React hooks, it's a common practice to use array destructuring. For example, built-in functions:</p>
<pre><code class="language-ts">const [counter, setCounter] = useState(0)
</code></pre>
<p>Libraries for React hooks would natural pick the similar philosophy, for example <a href="https://github.com/streamich/react-use">react-use</a>:</p>
<pre><code class="language-ts">const [on, toggle] = useToggle(true)
const [value, setValue, remove] = useLocalStorage('my-key', 'foo')
</code></pre>
<p>The benefits of array destructuring is quite straightforward - you get the freedom to set the variable names with the clean looking.</p>
<h2>Destructuring Objects</h2>
<p>Instead of returning the getter and setter in React's <code>useState</code>, in Vue 3, a <code>ref</code> is created combining the getter and setter inside the single object. Naming is simpler and destructuring is no longer needed.</p>
<pre><code class="language-ts">// React
const [counter, setCounter] = useState(0)
console.log(counter)        // get
setCounter(counter + 1)     // set

// Vue 3
const counter = ref(0)
console.log(counter.value)  // get
counter.value++             // set
</code></pre>
<p>Since we don't need to rename the same thing twice for getter and setter like React does, in <a href="https://github.com/antfu/vueuse">VueUse</a>, I implemented most of the functions with object returns, like:</p>
<pre><code class="language-ts">const { x, y } = useMouse()
</code></pre>
<p>Using objects gives users more flexibility like</p>
<pre><code class="language-ts">// no destructing, clear namespace
const mouse = useMouse()

mouse.x
</code></pre>
<pre><code class="language-ts">// use only part of the value
const { y } = useMouse()
</code></pre>
<pre><code class="language-ts">// rename things
const { x: mouseX, y: mouseY } = useMouse()
</code></pre>
<p>While it's been good for different preferences and named attributes can be self-explaining, the renaming could be somehow verbose than array destructuring.</p>
<h2>Support Both</h2>
<p>What if we could support them both? Taking the advantages on each side and let users decide which style to be used to better fit their needs.</p>
<p>I did saw one library supports such usage once but I can't recall which. However, this idea buried in mind since then. And now I am going to experiment it out.</p>
<p>My assumption is that it returns an object with both behaviors of <code>array</code> and <code>object</code>. The path is clear, either to make an <code>object</code> like <code>array</code> or an <code>array</code> like <code>object</code>.</p>
<h3>Make an object behaves like an array</h3>
<p>The first possible solution comes up to my mind is to make an object behaves like an array, as you probably know, arrays are actually objects with number indexes and some prototypes. So the code would be like:</p>
<pre><code class="language-ts">const data = {
  foo: 'foo',
  bar: 'bar',
  0: 'foo',
  1: 'bar',
}

let { foo, bar } = data
let [ foo, bar ] = data // ERROR!
</code></pre>
<p>But when we destructure it as an array, it will throw out this error:</p>
<pre><code class="language-ts">Uncaught TypeError: data is not iterable
</code></pre>
<p>Before we working on how to make an object iterable, let's try the other direction first.</p>
<h3>Make an array behaves like an object</h3>
<p>Since arrays are objects, we should be able to extend it, like</p>
<pre><code class="language-ts">const data = ['foo', 'bar']
data.foo = 'foo'
data.bar = 'bar'

let [ foo, bar ] = data
let { foo, bar } = data
</code></pre>
<p>This works and we can call it a day now! However, if you are a perfectionist, you will find there is an edge case not be well covered. If we use the rest pattern to retrieve the remaining parts, the number indexes will unexpectedly be included in the rest object.</p>
<pre><code class="language-ts">let { foo, ...rest } = data
</code></pre>
<p><code>rest</code> will be:</p>
<pre><code class="language-ts">{
  bar: 'bar',
  0: 'foo',
  1: 'bar'
}
</code></pre>
<h3>Iterable Object</h3>
<p>Let's go back to our first approach to see if we can make an object iterable. And luckily, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator"><code>Symbol.iterator</code></a> is designed for the task! The document shows exactly the usage, doing some modification and we get this:</p>
<pre><code class="language-ts">const data = {
  foo: 'foo',
  bar: 'bar',
  *[Symbol.iterator]() {
    yield 'foo'
    yield 'bar'
  },
}

let { foo, bar } = data
let [ foo, bar ] = data
</code></pre>
<p>It works well but the <code>Symbol.iterator</code> will still be included in the rest pattern.</p>
<pre><code class="language-ts">let { foo, ...rest } = data

// rest
{
  bar: 'bar',
  Symbol(Symbol.iterator): ƒ*
}
</code></pre>
<p>Since we are working on objects, it shouldn't be hard to make some properties not enumerable. By using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> with <code>enumerable: false</code>:</p>
<pre><code class="language-ts">const data = {
  foo: 'foo',
  bar: 'bar',
}

Object.defineProperty(data, Symbol.iterator, {
  enumerable: false,
  value: function*() {
    yield 'foo'
    yield 'bar'
  },
})
</code></pre>
<p>Now we are successfully hiding the extra properties!</p>
<pre><code class="language-ts">let { foo, ...rest } = data

// rest
{
  bar: 'bar'
}
</code></pre>
<h2>Generator</h2>
<p>If you don't like the usage of generators, we can implement it with pure functions, following <a href="https://itnext.io/introduction-to-javascript-iterator-eac78849e0f7#:~:text=An%20iterator%20is%20an%20object,new%20iterator%20for%20each%20call">this article</a>.</p>
<pre><code class="language-ts">Object.defineProperty(clone, Symbol.iterator, {
  enumerable: false,
  value() {
    let index = 0
    let arr = [foo, bar]
    return {
      next: () =&gt; ({
        value: arr[index++],
        done: index &gt; arr.length,
      })
    }
  }
})
</code></pre>
<h2>TypeScript</h2>
<p>To me, it's meaningless if we could not get proper TypeScript support on this. Surprisingly, TypeScript support such usage almost out-of-box. Just simply use the <a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types"><code>&amp;</code> operator</a> to make insertion of the object and array type. Destructuring will properly infer the types in both usages.</p>
<pre><code class="language-ts">type Magic = { foo: string, bar: string } &amp; [ string, string ]
</code></pre>
<h2>Take Away</h2>
<p>Finally, I made it a general function to merge arrays and objects intro the isomorphic destructurable. You can just copy the TypeScript snippet below to use it. Thanks for reading through!</p>
<blockquote>
<p>Please note this does NOT support IE11. More details: <a href="https://caniuse.com/?search=Symbol.iterator">Supported browers</a></p>
</blockquote>
<pre><code class="language-ts">function createIsomorphicDestructurable&lt;
  T extends Record&lt;string, unknown&gt;,
  A extends readonly any[]
&gt;(obj: T, arr: A): T &amp; A {

  const clone = { ...obj }

  Object.defineProperty(clone, Symbol.iterator, {
    enumerable: false,
    value() {
      let index = 0
      return {
        next: () =&gt; ({
          value: arr[index++],
          done: index &gt; arr.length,
        })
      }
    }
  })

  return clone as T &amp; A
}
</code></pre>
<h4>Usage</h4>
<pre><code class="language-ts">const foo = { name: 'foo' }
const bar: number = 1024

const obj = createIsomorphicDestructurable(
  { foo, bar } as const,
  [ foo, bar ] as const
)

let { foo, bar } = obj
let [ foo, bar ] = obj
</code></pre>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
            <enclosure url="https://antfu.me/images/destructuring.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Watch with @vue/reactivity]]></title>
            <link>https://antfu.me/posts/watch-with-reactivity</link>
            <guid>https://antfu.me/posts/watch-with-reactivity</guid>
            <pubDate>Fri, 18 Sep 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[A brief intro of how it works and a guide to implementing the (missing) `watch` on your own.]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p><a href="https://twitter.com/antfu7/status/1298667080804233221">As you probably know</a>, the things I excited most in Vue 3 are the <a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a> and the <a href="https://v3.vuejs.org/guide/reactivity.html">reactivity system</a>. With the Composition API we can reuse logics and states across components or even apps. What's better? The underhood reactivity system is decoupled from Vue, which means you can use it almost everywhere, even without UI.</p>
<p>Here are some proof of concepts for using the reactivity system outside of Vue:</p>
<ul>
<li>
<p><a href="https://github.com/yyx990803/vue-lit"><code>@vue/lit</code></a> is a minimal framework wrote by Evan combining <a href="https://github.com/vuejs/vue-next/tree/master/packages/reactivity"><code>@vue/reactivity</code></a> and <a href="https://lit-html.polymer-project.org/"><code>lit-html</code></a>. It can run directly in browsers, with the almost identical experience as Vue Composition API.</p>
</li>
<li>
<p><a href="https://github.com/antfu/reactivue"><code>ReactiVue</code></a> ports Vue Composition API to React. It also provides React's lifecycles in the Vue style.</p>
</li>
</ul>
<p>Furthermore, you can even use Vue's libraries in them. Tested with <a href="https://github.com/antfu/vueuse"><code>VueUse</code></a> and <a href="https://github.com/posva/pinia"><code>pinia</code></a> in <a href="https://github.com/antfu/reactivue"><code>ReactiVue</code></a>, and they just work. You can find <a href="https://github.com/antfu/reactivue#using-vues-libraries">more details and examples here</a>.</p>
<p>I am also experimenting more possibility of Vue reactivity in other scenarios, for example <a href="https://twitter.com/antfu7/status/1305313110903779330?s=20">reactive file system</a>, in a project called <code>tive</code>. It's currently a WIP private repo, but keep tuned, I get more to come 😉!</p>
<h2>Understanding <code>@vue/reactivity</code></h2>
<p>&quot;reactive objects&quot; returned by <code>ref()</code> or <code>reactive()</code> are actually <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a>. Those proxies will trigger some actions to track the changes on properties accessing or writing.</p>
<p>For a simplified example,</p>
<pre><code class="language-ts">const reactive = (target) =&gt; new Proxy(target, {
  get(target, prop, receiver) {
    track(target, prop)
    return Reflect.get(...arguments) // get the original data
  },
  set(target, key, value, receiver) {
    trigger(target, key)
    return Reflect.set(...arguments) // set the original data
  }
})

const obj = reactive({
  hello: 'world'
})

console.log(obj.hello) // `track()` get called
obj.hello = 'vue' // `trigger()` get called
</code></pre>
<p>So in this way, vue can be notified when those properties get accessed or when they be modified.</p>
<blockquote>
<p>For more detailed explanations, check out the <a href="https://v3.vuejs.org/guide/reactivity.html#what-is-reactivity">official docs</a></p>
</blockquote>
<h3>Computed</h3>
<p>Since we are able to know those events, we can start diving into the <code>computed</code> which is where the &quot;reactive&quot; magic start shining.</p>
<p><code>computed</code> is like a getter that auto collects the reactive dependencies source and auto re-evaluate when they get changed.</p>
<p>For example,</p>
<pre><code class="language-ts">const counter = ref(1)
const multiplier = ref(2)

const result = computed(() =&gt; counter.value * multiplier.value)

console.log(result.value) // 2
counter.value += 1
console.log(result.value) // 4
</code></pre>
<p>To know how the <code>computed</code> work, we need to dig into the lower level API <code>effect</code> first.</p>
<h2>Effect</h2>
<p><code>effect</code> is a new API introduced in Vue 3. Underneath, it's the engine powers the &quot;reactivity&quot; in <code>computed</code> and <code>watch</code>. For the most of the time, you don't need to directly use it. But knowing it well helps you understand the reactivity system much easier.</p>
<p><code>effect</code> takes the first argument as the <code>getter</code> and a second argument for the options. The <code>getter</code> is the function that collect its deps on each run via their <code>track()</code> hooks. The field <code>scheduler</code> in options provides a way to invoke a custom function when the deps change.</p>
<p>So basically, you can write a simple <code>computed</code> on your own like:</p>
<pre><code class="language-ts">const computed = (getter) =&gt; {
  let value
  let dirty = true
  
  const runner = effect(getter, {
    lazy: true,
    scheduler() {
      dirty = true // deps changed
    }
  })
  
  // return should be a `Ref` in real world, simplified here
  return {
    get value() {
      if (dirty) {
        value = runner() // re-evaluate
        dirty = false
      }
      return value
    }
  }
}
</code></pre>
<p>If you really interested in how it works in Vue, check out <a href="https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/computed.ts">the source code here</a></p>
<h2>Build yourself a <code>watch</code></h2>
<p>We have done the most important APIs in <code>@vue/reactivity</code> now, which is <code>ref</code> <code>reactive</code> <code>effect</code> <code>computed</code>.</p>
<p>Oh wait, we are missing the <code>watch</code> here!</p>
<pre><code class="language-js">import { watch } from '@vue/reactivity' // does NOT exist!
</code></pre>
<p>If you take a look at Vue 3's source code, you will find that <code>watch</code> is actually <a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/apiWatch.ts">implemented in <code>@vue/runtime-core</code></a>, along with the Vue's component model and lifecycles. The main reason for this is that <code>watch</code> is deep bound with the component's lifecycles (auto dispose, invalidate, etc.). But it shouldn't be the thing to keep you from using it outside of Vue.</p>
<p>Let's implement the <code>watch</code> our own!</p>
<h3>The Basic</h3>
<p>Let's take a look at Vue's watch interface first</p>
<pre><code class="language-ts">const count = ref(0)

watch(
  () =&gt; count.value,
  (newValue) =&gt; {
    console.log(`count changed to: ${newValue}!`)
  }
)

count.value = 2
// count changed to: 2!
</code></pre>
<p>With the knowledge of <code>effect</code>, it's quite straight forward to implement</p>
<pre><code class="language-ts">const watch = (getter, fn) =&gt; {
  const runner = effect(getter, {
    lazy: true,
    scheduler: fn
  }
  
  // a callback function is returned to stop the effect
  return () =&gt; stop(runner)
}
</code></pre>
<p>Watch is lazy by default in Vue, you can add the third options to give control to the users.</p>
<h3>Watch for Ref</h3>
<p>You may also notice that the Vue's <code>watch</code> also allows passing the ref directly to it.</p>
<pre><code class="language-ts">watch(
  count,
  () =&gt; { /* onChanged */ }
)
</code></pre>
<p>For that, just wrap it into a getter will do</p>
<pre><code class="language-ts">const watch = (source, fn) =&gt; {
  const getter = isRef(source)
    ? () =&gt; source.value
    : source

  const runner = effect(getter, {
    lazy: true,
    scheduler: fn
  }

  return () =&gt; stop(runner)
}
</code></pre>
<h3>Watch Deeply</h3>
<p>One other great feature about <code>watch</code> is that it allows you to watch on deep changes.</p>
<pre><code class="language-ts">const state = reactive({
  info: {
    name: 'Anthony',
  }
})

watch(state, () =&gt; { console.log('changed!') }, { deep: true })

state.info.name = 'Anthony Fu'
// changed!
</code></pre>
<p>To implement this feature, you need to collect the <code>track()</code> events on every nested property. We can achieve that with a <code>traverse</code> function.</p>
<pre><code class="language-ts">function traverse(value, seen = new Set()) {
  if (!isObject(value) || seen.has(value))
    return value

  seen.add(value) // prevent circular reference 
  if (isArray(value)) {
    for (let i = 0; i &lt; value.length; i++)
      traverse(value[i], seen)
  }
  else {
    for (const key of Object.keys(value))
      traverse(value[key], seen)
  }
  return value
}

const watch = (source, fn, { deep, lazy = true }) =&gt; {
  let getter = isRef(source)
    ? () =&gt; source.value
    : isReactive(source) 
      ? () =&gt; source
      : source
    
  if (deep)
    getter = () =&gt; traverse(getter())
    
  const runner = effect(getter, {
    lazy,
    scheduler: fn
  }

  return () =&gt; stop(runner)
}
</code></pre>
<p>Done! The thing left to do is to polish, adding overloads to make it more flexible, add more options to get better control, and handle some edge cases. Then you should get yourself a good start for using a custom <code>watch</code>!</p>
<h2>Lifecycles</h2>
<p>In Vue, <code>computed</code> and <code>watch</code> will automatically bind their <code>effect</code> runner to the current component instance. When the component get unmounted, the effects bond to it will be auto disposed. More specially, you can read <a href="https://github.com/vuejs/vue-next/blob/985bd2bcb5fd8bccd1c15c8c5d89a6919fd73922/packages/runtime-core/src/apiWatch.ts#L294">the source code here</a>.</p>
<p>Since we don't have an instance, if you want to stop those effects, you have to do them manually. When you have multiple effects in used, to stop them together, you have to manually collect them together. One easier way is to mock similar lifecycles like Vue. This requires some amount of works, I will explain that in another blog post. Please keep tuned.</p>
<h2>Take Away</h2>
<p>Thanks for reading! And hope it is helpful for you to understand and better play with the Vue reactivity system. If you want to have the <code>watch</code> outside of Vue, I made one for you (much more robust than the examples above for sure).</p>
<pre class="block language-bash">
npm i <a href='https://github.com/antfu/vue-reactivity-watch' target='_blank'>@vue-reactivity/watch</a>
</pre> 
<p>Have fun ;P</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Journey with Icons]]></title>
            <link>https://antfu.me/posts/journey-with-icons</link>
            <guid>https://antfu.me/posts/journey-with-icons</guid>
            <pubDate>Sun, 16 Aug 2020 16:00:00 GMT</pubDate>
            <description><![CDATA[To solve the pain I faced in using icons for the web, I built several tools to make the DX better.]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<blockquote>
<p>Update Sep. 2021: <a href="/posts/journey-with-icons-continues">Journey with Icons Continues</a></p>
</blockquote>
<h3>TL;DR</h3>
<p>To solve the pain I faced in using icons for the web, I built the following tools to make the DX better.</p>
<h4>Apps</h4>
<ul>
<li><a href="https://github.com/antfu/icones">Icônes</a> - Icon Explorer with Instant Fuzzy searching</li>
<li><a href="https://github.com/antfu/vscode-iconify">Iconify IntelliSense</a> - VS Code Extension for inline icon previewing</li>
<li><a href="https://github.com/antfu/vitesse">Vitesse</a> - An Opinionated Vite Starter Template</li>
</ul>
<h4>Tools</h4>
<ul>
<li><a href="https://github.com/antfu/purge-icons">PurgeIcons</a> - Bundles icons on demand</li>
<li><a href="https://github.com/antfu/svg-packer">SVG Packer</a> - Pack SVGs to Icon Fonts - In Browser</li>
</ul>
<p>Would be nice if you are willing to give them a try. As there are still a lot of works to be done, contributions are greatly welcome :)</p>
<h2>Journey with Icons</h2>
<p>I make websites and small web-based utilities from time to time. Every time I build them, I take care of the design by myself. Amount of the different aspects, icons always play a big role to me. <a href="https://materialdesignicons.com/">Material Design Icons</a> is the icon set I used most overtime, it has an excellent design foundation from Google and a wide range of icons maintained by the community. And the most important fact is that it has a complete tooling ecosystem - svgs with js, web fonts or even being built-in supported by Vuetify. I could just plugin it in most any kind of apps with very low effort.</p>
<p>However, if you want to try some other icon sets for different looks &amp; feels, you may not be that lucky. Many awesome icon-sets only offer SVGs for download and need to be manually imported to your projects. This could be a laborious and time-consuming work, even just preview them on your apps.</p>
<p>Fortunately, I found <a href="https://iconify.design/">Iconify</a> - a unified icons framework that offers over 6,000 icons from 80+ popular icon sets with a single CDN entry and on demand loading. The usage would be something like this:</p>
<pre><code class="language-html">&lt;!--Import Framework--&gt;
&lt;script src=&quot;https://code.iconify.design/1/1.0.7/iconify.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;!--Use an icon from Font Awesome--&gt;
&lt;span class=&quot;iconify&quot; data-icon=&quot;fa:home&quot;&gt;&lt;/span&gt;

&lt;!--Use another icon from Material Design Icons--&gt;
&lt;span class=&quot;iconify&quot; data-icon=&quot;mdi:flask&quot;&gt;&lt;/span&gt;
</code></pre>
<p>It's done. You get access to all the 6,000 icons with in an unfied syntax. As it's on-demand, you can switch your icon systems whenever you want without worrying about the setup or the bundle size. It's also framework independent, which means you can use it in Vue, React, Svelte, plain html or whatever you want.</p>
<p>This looks so good and the story should end here, however, it does have some limitations. As it's loaded on demand via web queries with its icon services, there will be a visible delay for icons to be loaded on the first page, especially when users have unstable connections to the Iconify servers. Also, you might have some logic to change icons with user interactions, Iconify will only start to request the icon when you actually rendered the id into the DOM. This causes some flickers on the icon switching which you possibly want to avoid.</p>
<p>The solution for this is quite straightforward, preloading the icons and the icon rendering could become synchronized. However, loading the entire icon set will impact your bundle size while manually picking what you used could be laborious and make it less flexible.</p>
<h3><a href="https://github.com/antfu/purge-icons">PurgeIcons</a></h3>
<p>Inspired by <a href="https://purgecss.com/">PurgeCSS</a>, I made the tool called <a href="https://github.com/antfu/purge-icons">PurgeIcons</a>. It statical analyzes your code and generates the <a href="https://docs.iconify.design/sources/bundles/">icon bundle</a> on-demand.</p>
<p><img src="https://user-images.githubusercontent.com/11247099/89781398-ce625a80-db45-11ea-86bf-d50471c526b7.gif" alt=""></p>
<p>Along with <a href="https://github.com/antfu/purge-icons/tree/master/packages/vite-plugin-purge-icons/README.md">the Vite plugin</a>, you can simplify import this inline in your app's entry, and the icons you use will be bundled into your code and load them synchronously.</p>
<pre><code class="language-ts">import { createApp } from 'vue'
import App from './App.vue'

import '@purge-icons/generated' // &lt;-- This

createApp(App).mount('#app')
</code></pre>
<p>It also provides a CLI tool and plugins for <a href="https://github.com/antfu/purge-icons/tree/main/packages/purge-icons-webpack-plugin">Webpack</a> and <a href="https://github.com/antfu/purge-icons/tree/main/packages/rollup-plugin-purge-icons">Rollup</a>. More frameworks support like Vue CLI, Nuxt, Gridsome or even plain html are coming soon.</p>
<p>With it, the tooling is kinda perfect to me now - I can use any icons without any compromise in the runtime. If you want to give it a try, I also made a pre-configured start template <a href="https://github.com/antfu/vitesse">🏕 Vitesse</a> with PurgeIcons built-in.</p>
<h2>Icon Searching</h2>
<p>The tooling gets solved, here comes to my another pain for a long time - searching for icons.</p>
<p>I live in China, my network conditions are usually quite unstable for oversee connections. It often took me around 30 seconds to get the searching in <a href="https://materialdesignicons.com/">Material Design Icons</a> or <a href="https://iconify.design/">Iconify</a>. And for most of the time, you won't get the perfect icons on your first try. Repeating searching for multiple times with a huge delay is just killing me.</p>
<p>And so, I finally get some time and motivation to work on making one my own recently. Also considering this being a chance for me to try Vue 3 + Vite and to learn Tailwind CSS.</p>
<h3>Icônes</h3>
<p>By the power of Iconify, I can only ship with the icon IDs and leave the icon loading task to Iconify. In this way, searching could be done locally - instantly.</p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/1.png" alt=""></p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/2.png" alt=""></p>
<p>With Iconify's data collection, it can get access to all the 80+ icon sets within a single place.</p>
<p>I also made a small utility called <a href="https://github.com/antfu/svg-packer">SVG Packer</a> for Icônes. With it, you can select the icons you want and pack them into ready to used icon fonts.</p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/5.png" alt=""></p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/3.png" alt=""></p>
<blockquote>
<p>Tips: You can also copy the icons as Vue or React components</p>
</blockquote>
<p>Try it out if you haven't. A fully-offline electron version is also coming soon.</p>
<h2>Editor Support</h2>
<p>Browsing and searching for icons are good to me now. Now comes to the editor integration. It's actually kinda hard to know what the icons look like from their IDs. Auto-completion for IDs is also a good feature I would love to have.</p>
<h3><a href="https://github.com/antfu/vscode-iconify">Iconify IntelliSense</a> for VS Code</h3>
<p>With a lot of inspirations from the <a href="https://github.com/lukas-tr/vscode-materialdesignicons-intellisense">VS Code extension for MDI</a>, Iconify IntelliSense was born.</p>
<p><img src="https://github.com/antfu/vscode-iconify/raw/master/screenshots/preview-1.png" alt=""></p>
<p>Loading icon data and cache them on demand, it encoded svgs into data urls to be displayed as images in VS Code. With the <a href="https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions">TextEditorDecoration</a> API, I achieve the feature to replace the icon IDs with the icon image itself in place. The icons will become visible and editable when you move the cursor around them.</p>
<p>Auto-completion with icon preview is also available. By typing the icon set id and the following delimiter colon <code>:</code>, a list of icons in the set will popup and you may continue type to do a simple search.</p>
<h3>Journey is not ended</h3>
<p>These apps and tools solved my long pain with icons. I can focus on bringing ideas to life much more efficiently. I will call it a page for no. Howeverr, the journey is not yet ended. I am still passionate about exploring how the tooling for icons could go. And also, keep polishing these tools to make them easier to use and integrate. I wish they could benefit more developers and designers and make site building more simple and pleasant.</p>
<p>Glad if you found them useful to you as well. And thanks for reading XD.</p>
<h3>Continues</h3>
<p>Enjoy the journey and the tools? Here is how it continues in Sep. 2021:</p>
<p><a href="/posts/journey-with-icons-continues">Journey with Icons Continues</a></p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Make Libraries Working with Vue 2 and 3]]></title>
            <link>https://antfu.me/posts/make-libraries-working-with-vue-2-and-3</link>
            <guid>https://antfu.me/posts/make-libraries-working-with-vue-2-and-3</guid>
            <pubDate>Wed, 01 Jul 2020 14:00:00 GMT</pubDate>
            <description><![CDATA[Try Vue Demi!]]></description>
            <content:encoded><![CDATA[<p>Today, Evan has announced that the first RC of Vue 3 <a href="https://github.com/vuejs/rfcs/issues/183">will be released in mid-July</a>. The post suggests library/plugin authors to start migrating the support for Vue 3. But as the APIs and behaviors have changed a lot, is that possible to make our libraries support Vue 2 and 3 at the same time?</p>
<h2>Universal Code</h2>
<p>The most simple way is to write universal code that works in both versions without any additional modification, just like people would do for <a href="https://python-future.org/compatible_idioms.html">Python 2 and 3</a>. Simple does not mean it's easy. Write such components requires you to avoid <strong>things that newly introduced in Vue 3</strong> and <strong>things that deprecated from Vue 2</strong>. In other words, you can't use:</p>
<ul>
<li>Composition API</li>
<li><code>.sync</code> <code>.native</code> modifiers</li>
<li>Filters</li>
<li><a href="/posts/vue-3-notes#-use-markraw-for-vendor-objects">3rd-parties vendor objects</a></li>
<li>etc. (let me know if I missed anything and I will update the list)</li>
</ul>
<p>This just makes life harder and you can't benefit from the new awesome APIs in Vue 3.</p>
<h2>Use Branches</h2>
<p><a href="https://github.com/vuejs/rfcs/issues/183#issuecomment-652134760">A reply</a> to <a href="https://github.com/vuejs/rfcs/issues/183#issuecomment-651944231">this problem</a> from a core team member suggests using different branches to separate your support for each targeting version. I think it's a good solution for existing and mature libraries as their codebases are usually more stable and version targeting optimization might require them to have better code isolations.</p>
<p>The drawback of this is that you will need to maintain two codebases which double your workload. For small scale libraries or new libraries that want to support both versions, doing bugfix or feature supplements twice is just no ideal. I would not recommend using this approach at the very beginning of your projects.</p>
<h2>Build Scripts</h2>
<p>In <a href="https://github.com/antfu/vueuse">VueUse</a>, I wrote <a href="https://github.com/antfu/vueuse/tree/master/scripts">some build scripts</a> to make the code imports from the target version's API while building. After that, I would need to publish two tags <code>vue2</code> <code>vue3</code> to distinguish different version supports. With this, I can wite the code once and make the library supports both Vue versions. The problem of it is that I need to build twice on each release and guide users to install with the corresponding plugin version (and manually install <a href="https://github.com/vuejs/composition-api"><code>@vue/composition-api</code></a> for Vue 2).</p>
<hr>
<p>It has been several months since I wrote VueUse. During this period, I am always trying to figure out a proper way to extract the logic from VueUse, so it can be reused and benefit other library authors. But after all, I still think it's just too complicated to be used in general.</p>
<p>However, at the moment I started to write this post, I came up with the idea - providing the universal interface for both versions. If it works, in this way, authors are no need to worried about the users' environments anymore.</p>
<p>And after some experiments...</p>
<h2>🎩 Introducing <a href="https://github.com/antfu/vue-demi">Vue Demi</a></h2>
<p><a href="https://github.com/antfu/vue-demi"><strong>Vue Demi</strong></a> is a developing utility that allows you to write Universal Vue Libraries for Vue 2 and 3. Without worrying about users' installed versions.</p>
<p>When you are going to create a Vue plugin/library, simply install <code>vue-demi</code> as your dependency and import anything related to Vue from it. Publish your plugin/library as usual, your package would become universal!</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;vue-demi&quot;: &quot;latest&quot;
  }
}
</code></pre>
<pre><code class="language-ts">import Vue, { ref, reactive } from 'vue-demi'
</code></pre>
<p>Underhood, it utilized the <a href="https://docs.npmjs.com/misc/scripts"><code>postinstall</code> npm hook</a>. After all packages get installed, <a href="https://github.com/antfu/vue-demi/blob/master/scripts/postinstall.js">the script</a> will start to check the installed Vue version and redirect the exports to based on the local Vue version. When working with Vue 2, it will also install <code>@vue/composition-api</code> automatically if it doesn't get installed.</p>
<p>You can also check <a href="https://github.com/antfu/vue-demi/tree/master/examples">the working examples</a>, where I created a demo library <a href="https://github.com/antfu/vue-demi/blob/master/examples/%40vue-demi/use-mouse/src/index.ts"><code>@vue-demi/use-mouse</code></a> with just a single file entry.</p>
<p>Please keep in mind that Vue Demi is experimental and there will definitely be some glitches. Feel free to give it a try and let me know if anything goes wrong.</p>
<p>Thanks and happy hacking!</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Vue 3 Migration Notes]]></title>
            <link>https://antfu.me/posts/vue-3-notes</link>
            <guid>https://antfu.me/posts/vue-3-notes</guid>
            <pubDate>Wed, 01 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>Note: This is my personal notes/tips for migrating to Vue 3 and will be updated overtime. Please refer to <a href="https://v3.vuejs.org">the official docs</a> for the complete changelog.</p>
</blockquote>
<p>Sorted by the importance of my personal sense.</p>
<h3>💫 use <code>markRaw</code> for vendor objects</h3>
<p>The new reactivity system proxied the object passed to the Vue context. For vendor objects or class instances, you need to wrap it with <code>markRaw</code> in order to disable the reactivity injection.</p>
<pre><code class="language-ts">// works in Vue 2
this.codemirror = CodeMirror.fromTextArea(el)

// in Vue 3 you need to use markRaw()
// otherwise the CodeMirror won't work as expected
this.codemirror = markRaw(CodeMirror.fromTextArea(el))
</code></pre>
<p>I think this is a pretty tricky one. You won't see any warn or error on initialization, but the internal state of the vendor object might be messed up. You might face errors that comes from the libraries while couldn't find out why (the example above took me one hour of debugging to find out).</p>
<h3>💫 <code>.sync</code> → <code>v-model:</code></h3>
<p><code>.sync</code> modifier is unified by <code>v-model:</code></p>
<pre><code class="language-html">&lt;!-- Vue 2 --&gt;
&lt;Component name.sync=&quot;name&quot;/&gt;

&lt;!-- Vue 3 --&gt;
&lt;Component v-model:name=&quot;name&quot;/&gt;
</code></pre>
<p><code>v-model</code> on native element would be <code>value/input</code> while on custom components, it changed to <code>modelValue</code> and <code>update:modelValue</code></p>
<h3>💫 <code>shims-vue.d.ts</code></h3>
<blockquote>
<p>Update: now you can use <a href="https://github.com/znck/vue-developer-experience/tree/master/packages/typescript-plugin-vue"><code>@vuedx/typescript-plugin-vue</code></a> for better type inference with SFC (no need for <code>shims-vue.d.ts</code> then)</p>
</blockquote>
<p>Changed to this:</p>
<pre><code class="language-ts">declare module '*.vue' {
  import { defineComponent } from 'vue';
  const Component: ReturnType&lt;typeof defineComponent&gt;;
  export default Component;
}
</code></pre>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Type Inferencing in Vue]]></title>
            <link>https://antfu.me/posts/type-inferencing-in-vue</link>
            <guid>https://antfu.me/posts/type-inferencing-in-vue</guid>
            <pubDate>Sun, 28 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p>As you may or may not know, I am working on preparing to release the v1.0 version for <a href="https://github.com/vuejs/composition-api">@vue/composition-api</a> recently. One of the current problems is that the type inference does not play well <a href="https://github.com/vuejs/composition-api/issues/338">#338</a>. So I get a chance to have a deeper look at <a href="https://github.com/vuejs/composition-api">vue-next</a>'s type implementations. I will tell you what I learned and how magic works in Vue.</p>
<p>Forget about the <code>setup()</code> function and <code>Composition API</code> for now, let talk about the options API in Vue 2 that everybody familiar with. In a classical example, we would have <code>data</code>, <code>computed</code>, <code>methods</code> and some other fields like this:</p>
<pre><code class="language-js">export default {
  data: {
    first_name: &quot;Anthony&quot;,
    last_name: &quot;Fu&quot;,
  },
  computed: {
    full_name() {
      return this.first_name + &quot; &quot; + this.last_name
    },
  },
  methods: {
    hi() {
      alert(this.full_name)
    }
  }
}
</code></pre>
<p>It works well in Javascript and putting all the context into <code>this</code> is pretty straightforward and easy to understand. But when you switch to TypeScript for static type checking. <code>this</code> will not be the context you expected. How can we make the types work for Vue like the example above?</p>
<h2>Type for <code>this</code></h2>
<p>To explicitly assign the type to <code>this</code>, we can simply use the <code>this parameter</code>:</p>
<pre><code class="language-ts">interface Context {
  $injected: string
}

function bar(this: Context, a: number) {
  this.$injected // ok
}
</code></pre>
<p>The limitation of this approach is that we will lose the signature of the method when working with a dict of methods:</p>
<pre><code class="language-ts">type Methods = Record&lt;string, (this: Context, ...args:any[]) =&gt; any&gt;

const methods: Methods = {
  bar(a: number) {
    this.$injected // ok
  }
}

methods.bar('foo', 'bar') // no error, the type of arguments becomes `any[]`
</code></pre>
<p>We would not want to ask users to explicitly type <code>this</code> in every method in order to make the type checking works.<br>
So we will need another approach.</p>
<h3><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet"><code>ThisType</code></a></h3>
<p>After digging into Vue's code, I found an interesting TypeScirpt utility <code>ThisType</code>. The official doc says:</p>
<blockquote>
<p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual <code>this</code> type.</p>
</blockquote>
<p><code>ThisType</code> would affect all the nested functions. With it, we can have:</p>
<pre><code class="language-ts">type Methods = {
  double: (a: number) =&gt; number
  deep: {
    nested: {
      half: (a: number) =&gt; number
    }
  }
}

const methods: Methods &amp; ThisType&lt;Methods &amp; Context&gt; = {
  double(a: number) {
    this.$injected // ok
    return a * 2
  },
  deep: {
    nested: {
      half(a: number) {
        this.$injected // ok
        return a / 2
      }
    }
  }
}

methods.double(2) // ok
methods.double('foo') // error
methods.deep.nested.half(4) // ok
</code></pre>
<p>The typing works well, but it still requires users to define the type interface of Methods first. Can we make it infer itself automatically?</p>
<p>We can do that with function inference:</p>
<pre><code class="language-ts">type Options&lt;T&gt; = {
  methods?: T 
} &amp; ThisType&lt;T &amp; Context&gt;

function define&lt;T&gt;(options: Options&lt;T&gt;) {
  return options
}

define({
  methods: {
    foo() {
      this.$injected // ok
    },
  },
})
</code></pre>
<p>There is only one step left, to make context object dynamic inference from <code>data</code> and <code>computed</code>.</p>
<p>The full working demo would be:</p>
<pre><code class="language-ts">/* ---- Type ---- */
export type ExtractComputedReturns&lt;T extends any&gt; = {
  [key in keyof T]: T[key] extends (...args: any[]) =&gt; infer TReturn
    ? TReturn
    : never
}

type Options&lt;D = {}, C = {}, M = {}&gt; = {
  data: () =&gt; D
  computed: C
  methods: M
  mounted: () =&gt; void
  // and other options
} 
&amp; ThisType&lt;D &amp; M &amp; ExtractComputedReturns&lt;C&gt;&gt; // merge them together

function define&lt;D, C, M&gt;(options: Options&lt;D, C, M&gt;) {}

/* ---- Usage ---- */
define({
  data() {
    return {
      first_name: &quot;Anthony&quot;,
      last_name: &quot;Fu&quot;,
    }
  },
  computed: {
    fullname() {
      return this.first_name + &quot; &quot; + this.last_name
    },
  },
  methods: {
    notify(msg: string) {
      alert(msg)
    }
  },
  mounted() {
    this.notify(this.fullname)
  },
})
</code></pre>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Domain Email]]></title>
            <link>https://antfu.me/posts/domain-email</link>
            <guid>https://antfu.me/posts/domain-email</guid>
            <pubDate>Wed, 17 Jun 2020 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Saw <a href="https://twitter.com/youyuxi/status/1272932071749619712">a tweet from Evan You</a> about the <a href="https://hey.com/">hey.com</a> mail service recently. I got interested in having a short and nice email address. My current one in Hotmail is just too long to even being spell out in talk. <code>hey.com</code> looks very nice but $99/year is not a very good deal to me. I decide to use my own domain for receiving emails.</p>
<p>I did this a couple years ago for another domain, I kinda remember an open-source tool allowing forwarding emails by just adding DNS record. I took some time to search for it but I didn't find the page matches with my memory. I went GitHub to search in my stared projects, it turns out the tool now becomes and Freemium SaaS <a href="https://forwardemail.net/">forwardemail.net</a> with a fresh new logo and website design that I can't even recognize it.</p>
<p>The DNS forwarding feature just works the same, but it requires you to log in and register your domain now. I am glad it now being more well documented and charging for premium supports which can help it sustain.</p>
<p>The config is quite simple as usual, just 3 DNS record:</p>
<pre><code class="language-html">MX   @  mx1.forwardemail.net  10
MX   @  mx2.forwardemail.net  20
TXT  @  forward-email=youremail@example.com
</code></pre>
<p>That’s it! It also provides some advanced configs, you can check <a href="https://forwardemail.net/en/faq">the doc here</a>.</p>
<p>While setting up and reading the docs, I learned that you can explicitly purge the cache for <a href="https://1.1.1.1/purge-cache/">Cloudflare DNS</a> and <a href="https://developers.google.com/speed/public-dns/cache">Google DNS</a>. That's a very good-to-know tip!</p>
<p>And now, you can say hi to me at <a href="mailto:hi@antfu.me">hi@antfu.me</a>!</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[New House]]></title>
            <link>https://antfu.me/posts/new-house</link>
            <guid>https://antfu.me/posts/new-house</guid>
            <pubDate>Fri, 12 Jun 2020 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>I always feel that I need a blog but I never have one.</p>
<p>So I took some time to rewrite my homepage and adding the blog section. and Hi, here I am :)</p>
<p>This time I gave a try on <a href="http://gridsome.org/">Gridsome</a> and it works petty well. I do love the <code>&lt;static-query&gt;</code> custom block that works even in components. The <a href="https://gridsome.org/docs/images/">progressive image</a> also solves my years of pain in making a photography portfolio (and I have never finished one).</p>
<p>While I was browsing Gridsome's starter templates, I found a great website <a href="https://forestry.io/">Forestry.io</a>. It's a Git-backed CMS that I can write and manage my blog posts in a nice GUI website and then commit back to Github. This is the feature that I wish to have for a long time, did not expect to see such a well built and nicely designed service out there.</p>
<p>As for the blog, I am likely to do some bilingual stuff in the future. Some posts will be written in English, some might be in Chinese. A switch button will be shown then. Also planned to post my photos in this site, which I would need to implement the gallery page for it.</p>
<p>The site is still WIP, if you have any thoughts or suggestions, please tell me via <a href="mailto:hi@antfu.me">email</a> or on <a href="https://twitter.com/antfu7">Twitter</a>. Thanks!</p>
<p>:)</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
    </channel>
</rss>